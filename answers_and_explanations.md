# 정답 및 해설

이 문서는 각 장의 확인 문제에 대한 정답과 해설을 제공합니다.

## 목차

### 01. 생성 패턴 (Creational Patterns)
- 01-1. [추상 팩토리 (Abstract Factory)](#01-1-추상-팩토리-abstract-factory)
- 01-2. [빌더 (Builder)](#01-2-빌더-builder)
- 01-3. 팩토리 메서드 (Factory Method)
- 01-4. 프로토타입 (Prototype)
- 01-5. 싱글톤 (Singleton)

### 02. 구조 패턴 (Structural Patterns)
- 02-1. 어댑터 (Adapter)
- 02-2. 브리지 (Bridge)
- 02-3. 컴포지트 (Composite)
- 02-4. 데코레이터 (Decorator)
- 02-5. 퍼사드 (Facade)
- 02-6. 플라이웨이트 (Flyweight)
- 02-7. 프록시 (Proxy)

### 03. 행위 패턴 (Behavioral Patterns)
- 03-1. 책임 연쇄 (Chain of Responsibility)
- 03-2. 커맨드 (Command)
- 03-3. 인터프리터 (Interpreter)
- 03-4. 반복자 (Iterator)
- 03-5. 중재자 (Mediator)
- 03-6. 메멘토 (Memento)
- 03-7. 옵저버 (Observer)
- 03-8. 상태 (State)
- 03-9. 전략 (Strategy)
- 03-10. 템플릿 메서드 (Template Method)
- 03-11. 방문자 (Visitor)




---

<a id="01-1-추상-팩토리-abstract-factory"></a>

### 01-1. 추상 팩토리 (Abstract Factory)

#### 문제 1
**문제**: 추상 팩토리 패턴의 주된 목적은 무엇인가?

- 보기
  - 객체 생명주기 전체(생성-사용-소멸)를 강제한다.
  - 관련 객체들의 일관된 세트를 생성하되, 구체 클래스를 감춘다.
  - 객체의 내부 상태를 캡슐화하고 복구한다.
  - 요청을 캡슐화하여 서로 다른 큐에 전달한다.

**정답**: 관련 객체들의 일관된 세트를 생성하되, 구체 클래스를 감춘다.

**해설**: 추상 팩토리는 서로 호환되는 제품군(예: 버튼·체크박스)을 한 번에 생성하게 해 일관성을 보장하고, 클라이언트가 구체 클래스를 알 필요 없이 인터페이스에만 의존하도록 만든다. 생명주기 관리나 상태 복구, 요청 캡슐화는 각각 다른 패턴(예: 템플릿 메서드/메멘토/커맨드)에 해당한다.

#### 문제 2
**문제**: 다음 중 스프링에서 추상 팩토리와 가장 밀접한 구성요소는 무엇인가?

- 보기
  - HandlerInterceptor
  - ApplicationContext/BeanFactory
  - RestTemplate
  - ViewResolver만 단독으로 사용

**정답**: ApplicationContext/BeanFactory

**해설**: 스프링 컨테이너는 설정과 조건(프로필, @Conditional 등)에 따라 구현체를 선택해 빈을 생성·주입한다. 이는 추상 팩토리처럼 “구체 타입 선택과 생성”을 캡슐화하는 동작과 동일한 핵심을 가진다. Interceptor/RestTemplate/ViewResolver는 각각 특정 관심사의 컴포넌트일 뿐, 제품군 생성 추상화와는 직접적이지 않다.

#### 문제 3 (복수 응답)
**문제**: 다음 중 추상 팩토리 패턴을 적용하기 좋은 경우를 모두 고르시오.

- 보기
  - 플랫폼(웹/모바일)에 따라 UI 컴포넌트 세트가 달라지는 경우
  - 데이터 접근 기술(JPA/JDBC)에 따라 리포지토리 구현군이 달라지는 경우
  - 단일 클래스 인스턴스 하나만 필요하고 변형이 없는 경우
  - 멀티 테넌트 환경에서 테넌트별 브랜드/테마 컴포넌트 세트가 다른 경우
  - 동일한 구현체를 영구적으로 고정해야 하는 경우

**정답**: 플랫폼(웹/모바일), 데이터 접근 기술(JPA/JDBC), 멀티 테넌트별 테마 구성

**해설**:
- 플랫폼별 UI는 버튼/체크박스/아이콘 등 호환되는 컴포넌트 “제품군”을 일관되게 교체해야 하므로 적합하다.
- 데이터 접근 기술별로 JPA/Mongo/JDBC 리포지토리 구현군이 달라지는 경우, 동일한 리포지토리 인터페이스를 유지하면서 팩토리로 제품군을 선택할 수 있다.
- 멀티 테넌트 환경에서 테넌트별 테마/브랜딩 컴포넌트 세트를 교체해야 하므로 추상 팩토리로 일관된 교체가 가능하다.
- 단일 클래스만 필요하거나 구현체를 고정해야 하는 경우는 추상 팩토리의 장점(교체/일관된 세트 생성)을 활용하지 못하므로 부적절하다.

# 정답 및 해설

이 문서는 각 장의 확인 문제에 대한 정답과 해설을 제공합니다.

## 목차

### 01. 생성 패턴 (Creational Patterns)
- 01-1. [추상 팩토리 (Abstract Factory)](#01-1-추상-팩토리-abstract-factory)
- 01-2. [빌더 (Builder)](#01-2-빌더-builder)
- 01-3. 팩토리 메서드 (Factory Method)
- 01-4. 프로토타입 (Prototype)
- 01-5. 싱글톤 (Singleton)

### 02. 구조 패턴 (Structural Patterns)
- 02-1. 어댑터 (Adapter)
- 02-2. 브리지 (Bridge)
- 02-3. 컴포지트 (Composite)
- 02-4. 데코레이터 (Decorator)
- 02-5. 퍼사드 (Facade)
- 02-6. 플라이웨이트 (Flyweight)
- 02-7. 프록시 (Proxy)

### 03. 행위 패턴 (Behavioral Patterns)
- 03-1. 책임 연쇄 (Chain of Responsibility)
- 03-2. 커맨드 (Command)
- 03-3. 인터프리터 (Interpreter)
- 03-4. 반복자 (Iterator)
- 03-5. 중재자 (Mediator)
- 03-6. 메멘토 (Memento)
- 03-7. 옵저버 (Observer)
- 03-8. 상태 (State)
- 03-9. 전략 (Strategy)
- 03-10. 템플릿 메서드 (Template Method)
- 03-11. 방문자 (Visitor)




---

<a id="01-1-추상-팩토리-abstract-factory"></a>

### 01-1. 추상 팩토리 (Abstract Factory)

#### 문제 1
**문제**: 추상 팩토리 패턴의 주된 목적은 무엇인가?

- 보기
  - 객체 생명주기 전체(생성-사용-소멸)를 강제한다.
  - 관련 객체들의 일관된 세트를 생성하되, 구체 클래스를 감춘다.
  - 객체의 내부 상태를 캡슐화하고 복구한다.
  - 요청을 캡슐화하여 서로 다른 큐에 전달한다.

**정답**: 관련 객체들의 일관된 세트를 생성하되, 구체 클래스를 감춘다.

**해설**: 추상 팩토리는 서로 호환되는 제품군(예: 버튼·체크박스)을 한 번에 생성하게 해 일관성을 보장하고, 클라이언트가 구체 클래스를 알 필요 없이 인터페이스에만 의존하도록 만든다. 생명주기 관리나 상태 복구, 요청 캡슐화는 각각 다른 패턴(예: 템플릿 메서드/메멘토/커맨드)에 해당한다.

#### 문제 2
**문제**: 다음 중 스프링에서 추상 팩토리와 가장 밀접한 구성요소는 무엇인가?

- 보기
  - HandlerInterceptor
  - ApplicationContext/BeanFactory
  - RestTemplate
  - ViewResolver만 단독으로 사용

**정답**: ApplicationContext/BeanFactory

**해설**: 스프링 컨테이너는 설정과 조건(프로필, @Conditional 등)에 따라 구현체를 선택해 빈을 생성·주입한다. 이는 추상 팩토리처럼 “구체 타입 선택과 생성”을 캡슐화하는 동작과 동일한 핵심을 가진다. Interceptor/RestTemplate/ViewResolver는 각각 특정 관심사의 컴포넌트일 뿐, 제품군 생성 추상화와는 직접적이지 않다.

#### 문제 3 (복수 응답)
**문제**: 다음 중 추상 팩토리 패턴을 적용하기 좋은 경우를 모두 고르시오.

- 보기
  - 플랫폼(웹/모바일)에 따라 UI 컴포넌트 세트가 달라지는 경우
  - 데이터 접근 기술(JPA/JDBC)에 따라 리포지토리 구현군이 달라지는 경우
  - 단일 클래스 인스턴스 하나만 필요하고 변형이 없는 경우
  - 멀티 테넌트 환경에서 테넌트별 브랜드/테마 컴포넌트 세트가 다른 경우
  - 동일한 구현체를 영구적으로 고정해야 하는 경우

**정답**: 플랫폼(웹/모바일), 데이터 접근 기술(JPA/JDBC), 멀티 테넌트별 테마 구성

**해설**:
- 플랫폼별 UI는 버튼/체크박스/아이콘 등 호환되는 컴포넌트 “제품군”을 일관되게 교체해야 하므로 적합하다.
- 데이터 접근 기술별로 JPA/Mongo/JDBC 리포지토리 구현군이 달라지는 경우, 동일한 리포지토리 인터페이스를 유지하면서 팩토리로 제품군을 선택할 수 있다.
- 멀티 테넌트 환경에서 테넌트별 테마/브랜딩 컴포넌트 세트를 교체해야 하므로 추상 팩토리로 일관된 교체가 가능하다.
- 단일 클래스만 필요하거나 구현체를 고정해야 하는 경우는 추상 팩토리의 장점(교체/일관된 세트 생성)을 활용하지 못하므로 부적절하다.


---

<a id="01-2-빌더-builder"></a>

### 01-2. 빌더 (Builder)

#### 문제 1
**문제**: 빌더 패턴의 핵심 아이디어로 가장 적절한 것은?

- 보기
  - 구체 팩토리별로 일관된 제품군을 생성한다.
  - 객체의 내부 상태를 스냅샷으로 저장하고 복구한다.
  - 복잡한 객체 생성을 단계별로 분리하고 최종 단계에서 완성한다.
  - 알고리즘의 골격을 정의하고 하위 클래스가 일부 단계를 재정의한다.

**정답**: 복잡한 객체 생성을 단계별로 분리하고 최종 단계에서 완성한다.

**해설**: 빌더는 많은 선택적 인자나 조건부 조립이 필요한 경우에 적합하며, 생성 과정을 단계별로 나누어 가독성과 안전성을 높인다. 템플릿 메서드/메멘토/추상 팩토리 등의 의도와는 다르다.

#### 문제 2
**문제**: 다음 중 스프링에서 "빌더" 스타일 API로 분류되기 어려운 것은?

- 보기
  - RestTemplateBuilder
  - WebClient.Builder
  - UriComponentsBuilder
  - JdbcTemplate 자체(쿼리 실행 도우미)

**정답**: JdbcTemplate 자체(쿼리 실행 도우미)

**해설**: JdbcTemplate은 쿼리 실행을 돕는 템플릿 유틸리티로, 최종 객체를 단계적으로 구성해 build()로 완성하는 전형적 빌더와는 성격이 다르다. 나머지는 모두 객체를 체이닝 설정 후 build() 혹은 toUri 등으로 생성한다.

#### 문제 3 (복수 응답)
**문제**: 빌더 패턴을 적용하기 좋은 경우를 모두 고르시오.

- 보기
  - 선택적 인자가 많은 불변 설정 객체를 만들 때
  - HTTP 클라이언트 구성 옵션(타임아웃/헤더/리트라이 등)을 단계적으로 설정할 때
  - 단일 생성자에 인자가 1~2개뿐인 단순 값 객체를 만들 때
  - 동일 절차로 프로파일별 다른 프리셋을 손쉽게 만들고 싶을 때
  - 런타임에 객체 제품군의 일관성을 강제하고 싶을 때

**정답**: 선택적 인자가 많은 불변 설정 객체, HTTP 클라이언트 구성, 프로파일별 프리셋 구성

**해설**:
- 불변 설정 객체에 선택적 속성이 많으면 빌더로 누락/순서 오류를 줄일 수 있다.
- HTTP 클라이언트는 옵션이 다양해 단계적 설정과 최종 build가 적합하다.
- 프로파일별 프리셋은 동일 절차로 다른 결과를 생성하므로 빌더의 장점이 크다.
- 인자가 매우 적은 단순 객체, 혹은 제품군 일관성 강제(이는 추상 팩토리의 관심사)는 빌더와 맞지 않는다.


---

<a id="01-3-팩토리-메서드-factory-method"></a>

### 01-3. 팩토리 메서드 (Factory Method)

#### 문제 1
**문제**: 팩토리 메서드 패턴의 핵심 아이디어로 가장 적절한 것은?

- 보기
  - 관련 객체들의 일관된 세트를 한 번에 생성한다.
  - 상위 알고리즘 속 생성 훅(factoryMethod)을 두고, 구체 생성은 하위 클래스에서 결정한다.
  - 복잡한 객체 생성을 단계별로 분해하여 최종 build()에서 완성한다.
  - 객체의 내부 상태를 스냅샷으로 저장하고 복구한다.

**정답**: 상위 알고리즘 속 생성 훅(factoryMethod)을 두고, 구체 생성은 하위 클래스에서 결정한다.

**해설**: 팩토리 메서드는 Creator의 알고리즘 흐름 안에 생성 훅(factoryMethod)을 두고, 어떤 Product를 만들지는 하위 클래스가 오버라이드해 결정합니다. 제품군 일관 생성은 추상 팩토리, 단계적 조립은 빌더, 상태 스냅샷은 메멘토의 의도입니다.

#### 문제 2
**문제**: 다음 중 스프링에서 ‘팩토리 메서드’로 보기 어려운 것은?

- 보기
  - @Configuration 클래스의 @Bean 메서드
  - RepositoryFactorySupport가 하위 클래스에 위임하는 생성 훅
  - AbstractViewResolver 계층의 View 생성 보호 메서드
  - RestTemplateBuilder.build()의 빌더 완성 메서드

**정답**: RestTemplateBuilder.build()의 빌더 완성 메서드

**해설**: build()는 빌더 패턴의 최종 생성 단계입니다. @Bean 메서드는 컨테이너가 호출하는 명시적 팩토리 메서드로 볼 수 있고, RepositoryFactorySupport/AbstractViewResolver 계층의 보호 메서드는 하위 클래스가 구체 생성을 결정하는 전형적 팩토리 메서드 훅입니다.

#### 문제 3 (복수 응답)
**문제**: 팩토리 메서드 패턴을 적용하기 좋은 경우를 모두 고르시오.

- 보기
  - 상위 흐름은 고정이나, 생성되는 타입만 바뀌는 확장 요구가 많을 때
  - 표현(HTML/JSON/CSV 등)별로 다른 View를 같은 흐름에서 선택해야 할 때
  - 선택적 속성이 많은 불변 설정 객체를 단계적으로 조립할 때
  - 프레임워크가 생성 시점을 제어하고 사용자는 확장 포인트에서 구체 생성을 결정할 때
  - 단일 구현만 영구적으로 고정해야 하는 경우

**정답**: 상위 흐름 고정·타입만 변경, 표현별 View 선택, 프레임워크 제어·사용자 확장 포인트

**해설**:
- 상위 흐름 고정 + 타입만 변경: Creator 템플릿을 유지하면서 하위 클래스 교체로 확장하기 좋습니다.
- 표현별 View 선택: 같은 컨트롤 흐름에서 다른 View(Product)를 선택·생성하기 적합합니다.
- 프레임워크 제어/사용자 확장: 생성 시점은 프레임워크가, 구체 생성은 확장 포인트에서 결정하는 구조는 전형적인 팩토리 메서드입니다.
- 불변 설정의 단계적 조립은 빌더의 관심사이며, 단일 구현을 영구 고정하는 경우는 팩토리 메서드의 장점이 약합니다.


---

<a id="01-4-프로토타입-prototype"></a>

### 01-4. 프로토타입 (Prototype)

#### 문제 1
**문제**: 프로토타입 패턴의 핵심 아이디어로 가장 적절한 것은?

- 보기
  - 상위 알고리즘 속 생성 훅을 두고 하위 클래스에서 구체 생성을 결정한다.
  - 복잡한 객체 생성을 단계별로 분리하여 최종 단계에서 완성한다.
  - 원형 인스턴스를 복제하여 새 객체를 만든다.
  - 관련 객체들의 일관된 세트를 한 번에 생성한다.

**정답**: 원형 인스턴스를 복제하여 새 객체를 만든다.

**해설**: 프로토타입의 본질은 “복제 기반 생성”입니다. new로 초기화 로직을 반복하는 대신, 이미 준비된 원형을 복사해 빠르게 인스턴스를 만듭니다. 생성 훅/단계별 조립/제품군 생성은 각각 팩토리 메서드/빌더/추상 팩토리의 의도입니다.

#### 문제 2
**문제**: 스프링의 prototype 스코프에 대한 설명으로 가장 올바른 것은?

- 보기
  - GoF Prototype처럼 원형 객체의 clone을 호출한다.
  - getBean 호출마다 컨테이너가 새 인스턴스를 만들어 준다.
  - 싱글톤 빈과 동일하게 1개 인스턴스만 유지한다.
  - 동일 빈 이름에 대해 항상 깊은 복사를 보장한다.

**정답**: getBean 호출마다 컨테이너가 새 인스턴스를 만들어 준다.

**해설**: 스프링의 prototype 스코프는 ‘매 요청 시 신규 생성’을 의미합니다. 내부적으로 clone을 강제하지 않으며, 깊은 복사를 보장하지도 않습니다. GoF Prototype은 원형 객체가 복제 규칙을 캡슐화하는 패턴으로 개념이 다릅니다.

#### 문제 3 (복수 응답)
**문제**: 다음 중 “깊은 복사”가 필요한 상황을 모두 고르시오.

- 보기
  - 원형과 복제본이 동일한 컬렉션 인스턴스를 공유하면 안 될 때
  - 불변 값 객체만으로 구성되어 공유 안전할 때
  - JPA 엔티티를 복제하며 연관 컬렉션을 독립적으로 편집해야 할 때
  - 식별자/감사 필드를 그대로 유지해야 할 때
  - 템플릿 DTO를 복제하되 내부 리스트를 새로 만들어야 할 때

**정답**: 원형과 복제본이 동일한 컬렉션 인스턴스를 공유하면 안 될 때, JPA 엔티티를 복제하며 연관 컬렉션을 독립적으로 편집해야 할 때, 템플릿 DTO를 복제하되 내부 리스트를 새로 만들어야 할 때

**해설**:
- 컬렉션/가변 참조 공유 금지: 원형과 복제본이 같은 리스트/맵을 공유하면 부작용이 발생합니다. 깊은 복사로 분리해야 합니다.
- JPA 연관 컬렉션: 독립 편집이 필요하면 컬렉션 요소 및 참조를 새로 만들어야 합니다(식별자 재설정 포함).
- 템플릿 DTO: 내부 리스트를 새로 만들어 원형과 복제본 간 상태 공유를 차단합니다.
- 불변 값 객체만으로 구성된 경우엔 얕은 복사도 안전합니다.
- 식별자/감사 필드는 보통 새로 생성/초기화해야 하며, ‘그대로 유지’는 도메인 규칙 위반 가능성이 큽니다.
