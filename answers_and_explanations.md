# 정답 및 해설

이 문서는 각 장의 확인 문제에 대한 정답과 해설을 제공합니다.

## 목차

### 01. 생성 패턴 (Creational Patterns)
- 01-1. [추상 팩토리 (Abstract Factory)](#01-1-추상-팩토리-abstract-factory)
- 01-2. [빌더 (Builder)](#01-2-빌더-builder)
- 01-3. [팩토리 메서드 (Factory Method)](#01-3-팩토리-메서드-factory-method)
- 01-4. [프로토타입 (Prototype)](#01-4-프로토타입-prototype)
- 01-5. [싱글톤 (Singleton)](#01-5-싱글톤-singleton)

### 02. 구조 패턴 (Structural Patterns)
- 02-1. [어댑터 (Adapter)](#02-1-어댑터-adapter)
- 02-2. [브리지 (Bridge)](#02-2-브리지-bridge)
- 02-3. [컴포지트 (Composite)](#02-3-컴포지트-composite)
- 02-4. [데코레이터 (Decorator)](#02-4-데코레이터-decorator)
- 02-5. [퍼사드 (Facade)](#02-5-퍼사드-facade)
- 02-6. [플라이웨이트 (Flyweight)](#02-6-플라이웨이트-flyweight)
- 02-7. [프록시 (Proxy)](#02-7-프록시-proxy)

### 03. 행위 패턴 (Behavioral Patterns)
- 03-1. [책임 연쇄 (Chain of Responsibility)](#03-1-책임-연쇄-chain-of-responsibility)
- 03-2. [커맨드 (Command)](#03-2-커맨드-command)
- 03-3. [인터프리터 (Interpreter)](#03-3-인터프리터-interpreter)
- 03-4. [반복자 (Iterator)](#03-4-반복자-iterator)
- 03-5. 중재자 (Mediator)
- 03-6. 메멘토 (Memento)
- 03-7. 옵저버 (Observer)
- 03-8. 상태 (State)
- 03-9. 전략 (Strategy)
- 03-10. 템플릿 메서드 (Template Method)
- 03-11. 방문자 (Visitor)

---

<a id="01-1-추상-팩토리-abstract-factory"></a>

### 01-1. 추상 팩토리 (Abstract Factory)

#### 문제 1
**문제**: 추상 팩토리 패턴의 주된 목적은 무엇인가?

- 보기
  - 객체 생명주기 전체(생성-사용-소멸)를 강제한다.
  - 관련 객체들의 일관된 세트를 생성하되, 구체 클래스를 감춘다.
  - 객체의 내부 상태를 캡슐화하고 복구한다.
  - 요청을 캡슐화하여 서로 다른 큐에 전달한다.

**정답**: 관련 객체들의 일관된 세트를 생성하되, 구체 클래스를 감춘다.

**해설**: 추상 팩토리는 서로 호환되는 제품군(예: 버튼·체크박스)을 한 번에 생성하게 해 일관성을 보장하고, 클라이언트가 구체 클래스를 알 필요 없이 인터페이스에만 의존하도록 만든다. 생명주기 관리나 상태 복구, 요청 캡슐화는 각각 다른 패턴(예: 템플릿 메서드/메멘토/커맨드)에 해당한다.

#### 문제 2
**문제**: 다음 중 스프링에서 추상 팩토리와 가장 밀접한 구성요소는 무엇인가?

- 보기
  - HandlerInterceptor
  - ApplicationContext/BeanFactory
  - RestTemplate
  - ViewResolver만 단독으로 사용

**정답**: ApplicationContext/BeanFactory

**해설**: 스프링 컨테이너는 설정과 조건(프로필, @Conditional 등)에 따라 구현체를 선택해 빈을 생성·주입한다. 이는 추상 팩토리처럼 “구체 타입 선택과 생성”을 캡슐화하는 동작과 동일한 핵심을 가진다. Interceptor/RestTemplate/ViewResolver는 각각 특정 관심사의 컴포넌트일 뿐, 제품군 생성 추상화와는 직접적이지 않다.

#### 문제 3 (복수 응답)
**문제**: 다음 중 추상 팩토리 패턴을 적용하기 좋은 경우를 모두 고르시오.

- 보기
  - 플랫폼(웹/모바일)에 따라 UI 컴포넌트 세트가 달라지는 경우
  - 데이터 접근 기술(JPA/JDBC)에 따라 리포지토리 구현군이 달라지는 경우
  - 단일 클래스 인스턴스 하나만 필요하고 변형이 없는 경우
  - 멀티 테넌트 환경에서 테넌트별 브랜드/테마 컴포넌트 세트가 다른 경우
  - 동일한 구현체를 영구적으로 고정해야 하는 경우

**정답**: 플랫폼(웹/모바일), 데이터 접근 기술(JPA/JDBC), 멀티 테넌트별 테마 구성

**해설**:
- 플랫폼별 UI는 버튼/체크박스/아이콘 등 호환되는 컴포넌트 “제품군”을 일관되게 교체해야 하므로 적합하다.
- 데이터 접근 기술별로 JPA/Mongo/JDBC 리포지토리 구현군이 달라지는 경우, 동일한 리포지토리 인터페이스를 유지하면서 팩토리로 제품군을 선택할 수 있다.
- 멀티 테넌트 환경에서 테넌트별 테마/브랜딩 컴포넌트 세트를 교체해야 하므로 추상 팩토리로 일관된 교체가 가능하다.
- 단일 클래스만 필요하거나 구현체를 고정해야 하는 경우는 추상 팩토리의 장점(교체/일관된 세트 생성)을 활용하지 못하므로 부적절하다.


---

<a id="01-2-빌더-builder"></a>

### 01-2. 빌더 (Builder)

#### 문제 1
**문제**: 빌더 패턴의 핵심 아이디어로 가장 적절한 것은?

- 보기
  - 구체 팩토리별로 일관된 제품군을 생성한다.
  - 객체의 내부 상태를 스냅샷으로 저장하고 복구한다.
  - 복잡한 객체 생성을 단계별로 분리하고 최종 단계에서 완성한다.
  - 알고리즘의 골격을 정의하고 하위 클래스가 일부 단계를 재정의한다.

**정답**: 복잡한 객체 생성을 단계별로 분리하고 최종 단계에서 완성한다.

**해설**: 빌더는 많은 선택적 인자나 조건부 조립이 필요한 경우에 적합하며, 생성 과정을 단계별로 나누어 가독성과 안전성을 높인다. 템플릿 메서드/메멘토/추상 팩토리 등의 의도와는 다르다.

#### 문제 2
**문제**: 다음 중 스프링에서 "빌더" 스타일 API로 분류되기 어려운 것은?

- 보기
  - RestTemplateBuilder
  - WebClient.Builder
  - UriComponentsBuilder
  - JdbcTemplate 자체(쿼리 실행 도우미)

**정답**: JdbcTemplate 자체(쿼리 실행 도우미)

**해설**: JdbcTemplate은 쿼리 실행을 돕는 템플릿 유틸리티로, 최종 객체를 단계적으로 구성해 build()로 완성하는 전형적 빌더와는 성격이 다르다. 나머지는 모두 객체를 체이닝 설정 후 build() 혹은 toUri 등으로 생성한다.

#### 문제 3 (복수 응답)
**문제**: 빌더 패턴을 적용하기 좋은 경우를 모두 고르시오.

- 보기
  - 선택적 인자가 많은 불변 설정 객체를 만들 때
  - HTTP 클라이언트 구성 옵션(타임아웃/헤더/리트라이 등)을 단계적으로 설정할 때
  - 단일 생성자에 인자가 1~2개뿐인 단순 값 객체를 만들 때
  - 동일 절차로 프로파일별 다른 프리셋을 손쉽게 만들고 싶을 때
  - 런타임에 객체 제품군의 일관성을 강제하고 싶을 때

**정답**: 선택적 인자가 많은 불변 설정 객체, HTTP 클라이언트 구성, 프로파일별 프리셋 구성

**해설**:
- 불변 설정 객체에 선택적 속성이 많으면 빌더로 누락/순서 오류를 줄일 수 있다.
- HTTP 클라이언트는 옵션이 다양해 단계적 설정과 최종 build가 적합하다.
- 프로파일별 프리셋은 동일 절차로 다른 결과를 생성하므로 빌더의 장점이 크다.
- 인자가 매우 적은 단순 객체, 혹은 제품군 일관성 강제(이는 추상 팩토리의 관심사)는 빌더와 맞지 않는다.


---

<a id="01-3-팩토리-메서드-factory-method"></a>

### 01-3. 팩토리 메서드 (Factory Method)

#### 문제 1
**문제**: 팩토리 메서드 패턴의 핵심 아이디어로 가장 적절한 것은?

- 보기
  - 관련 객체들의 일관된 세트를 한 번에 생성한다.
  - 상위 알고리즘 속 생성 훅(factoryMethod)을 두고, 구체 생성은 하위 클래스에서 결정한다.
  - 복잡한 객체 생성을 단계별로 분해하여 최종 build()에서 완성한다.
  - 객체의 내부 상태를 스냅샷으로 저장하고 복구한다.

**정답**: 상위 알고리즘 속 생성 훅(factoryMethod)을 두고, 구체 생성은 하위 클래스에서 결정한다.

**해설**: 팩토리 메서드는 Creator의 알고리즘 흐름 안에 생성 훅(factoryMethod)을 두고, 어떤 Product를 만들지는 하위 클래스가 오버라이드해 결정합니다. 제품군 일관 생성은 추상 팩토리, 단계적 조립은 빌더, 상태 스냅샷은 메멘토의 의도입니다.

#### 문제 2
**문제**: 다음 중 스프링에서 ‘팩토리 메서드’로 보기 어려운 것은?

- 보기
  - @Configuration 클래스의 @Bean 메서드
  - RepositoryFactorySupport가 하위 클래스에 위임하는 생성 훅
  - AbstractViewResolver 계층의 View 생성 보호 메서드
  - RestTemplateBuilder.build()의 빌더 완성 메서드

**정답**: RestTemplateBuilder.build()의 빌더 완성 메서드

**해설**: build()는 빌더 패턴의 최종 생성 단계입니다. @Bean 메서드는 컨테이너가 호출하는 명시적 팩토리 메서드로 볼 수 있고, RepositoryFactorySupport/AbstractViewResolver 계층의 보호 메서드는 하위 클래스가 구체 생성을 결정하는 전형적 팩토리 메서드 훅입니다.

#### 문제 3 (복수 응답)
**문제**: 팩토리 메서드 패턴을 적용하기 좋은 경우를 모두 고르시오.

- 보기
  - 상위 흐름은 고정이나, 생성되는 타입만 바뀌는 확장 요구가 많을 때
  - 표현(HTML/JSON/CSV 등)별로 다른 View를 같은 흐름에서 선택해야 할 때
  - 선택적 속성이 많은 불변 설정 객체를 단계적으로 조립할 때
  - 프레임워크가 생성 시점을 제어하고 사용자는 확장 포인트에서 구체 생성을 결정할 때
  - 단일 구현만 영구적으로 고정해야 하는 경우

**정답**: 상위 흐름 고정·타입만 변경, 표현별 View 선택, 프레임워크 제어·사용자 확장 포인트

**해설**:
- 상위 흐름 고정 + 타입만 변경: Creator 템플릿을 유지하면서 하위 클래스 교체로 확장하기 좋습니다.
- 표현별 View 선택: 같은 컨트롤 흐름에서 다른 View(Product)를 선택·생성하기 적합합니다.
- 프레임워크 제어/사용자 확장: 생성 시점은 프레임워크가, 구체 생성은 확장 포인트에서 결정하는 구조는 전형적인 팩토리 메서드입니다.
- 불변 설정의 단계적 조립은 빌더의 관심사이며, 단일 구현을 영구 고정하는 경우는 팩토리 메서드의 장점이 약합니다.


---

<a id="01-4-프로토타입-prototype"></a>

### 01-4. 프로토타입 (Prototype)

#### 문제 1
**문제**: 프로토타입 패턴의 핵심 아이디어로 가장 적절한 것은?

- 보기
  - 상위 알고리즘 속 생성 훅을 두고 하위 클래스에서 구체 생성을 결정한다.
  - 복잡한 객체 생성을 단계별로 분리하여 최종 단계에서 완성한다.
  - 원형 인스턴스를 복제하여 새 객체를 만든다.
  - 관련 객체들의 일관된 세트를 한 번에 생성한다.

**정답**: 원형 인스턴스를 복제하여 새 객체를 만든다.

**해설**: 프로토타입의 본질은 “복제 기반 생성”입니다. new로 초기화 로직을 반복하는 대신, 이미 준비된 원형을 복사해 빠르게 인스턴스를 만듭니다. 생성 훅/단계별 조립/제품군 생성은 각각 팩토리 메서드/빌더/추상 팩토리의 의도입니다.

#### 문제 2
**문제**: 스프링의 prototype 스코프에 대한 설명으로 가장 올바른 것은?

- 보기
  - GoF Prototype처럼 원형 객체의 clone을 호출한다.
  - getBean 호출마다 컨테이너가 새 인스턴스를 만들어 준다.
  - 싱글톤 빈과 동일하게 1개 인스턴스만 유지한다.
  - 동일 빈 이름에 대해 항상 깊은 복사를 보장한다.

**정답**: getBean 호출마다 컨테이너가 새 인스턴스를 만들어 준다.

**해설**: 스프링의 prototype 스코프는 ‘매 요청 시 신규 생성’을 의미합니다. 내부적으로 clone을 강제하지 않으며, 깊은 복사를 보장하지도 않습니다. GoF Prototype은 원형 객체가 복제 규칙을 캡슐화하는 패턴으로 개념이 다릅니다.

#### 문제 3 (복수 응답)
**문제**: 다음 중 “깊은 복사”가 필요한 상황을 모두 고르시오.

- 보기
  - 원형과 복제본이 동일한 컬렉션 인스턴스를 공유하면 안 될 때
  - 불변 값 객체만으로 구성되어 공유 안전할 때
  - JPA 엔티티를 복제하며 연관 컬렉션을 독립적으로 편집해야 할 때
  - 식별자/감사 필드를 그대로 유지해야 할 때
  - 템플릿 DTO를 복제하되 내부 리스트를 새로 만들어야 할 때

**정답**: 원형과 복제본이 동일한 컬렉션 인스턴스를 공유하면 안 될 때, JPA 엔티티를 복제하며 연관 컬렉션을 독립적으로 편집해야 할 때, 템플릿 DTO를 복제하되 내부 리스트를 새로 만들어야 할 때

**해설**:
- 컬렉션/가변 참조 공유 금지: 원형과 복제본이 같은 리스트/맵을 공유하면 부작용이 발생합니다. 깊은 복사로 분리해야 합니다.
- JPA 연관 컬렉션: 독립 편집이 필요하면 컬렉션 요소 및 참조를 새로 만들어야 합니다(식별자 재설정 포함).
- 템플릿 DTO: 내부 리스트를 새로 만들어 원형과 복제본 간 상태 공유를 차단합니다.
- 불변 값 객체만으로 구성된 경우엔 얕은 복사도 안전합니다.
- 식별자/감사 필드는 보통 새로 생성/초기화해야 하며, ‘그대로 유지’는 도메인 규칙 위반 가능성이 큽니다.


---

<a id="01-5-싱글톤-singleton"></a>

### 01-5. 싱글톤 (Singleton)

#### 문제 1
**문제**: 싱글톤 패턴의 핵심 의도로 가장 적절한 것은?

- 보기
  - 복잡한 객체 생성을 단계별로 분리한다.
  - 애플리케이션 전역에서 단 하나의 인스턴스만 존재하도록 보장한다.
  - 관련 객체들의 일관된 세트를 한 번에 생성한다.
  - 상위 알고리즘의 생성 훅을 하위 클래스가 결정한다.

**정답**: 애플리케이션 전역에서 단 하나의 인스턴스만 존재하도록 보장한다.

**해설**: 싱글톤의 핵심은 유일성과 전역 접근입니다. 단계적 생성은 빌더, 제품군 생성은 추상 팩토리, 생성 훅은 팩토리 메서드의 의도입니다.

#### 문제 2
**문제**: 다음 중 "스프링의 싱글톤 스코프"에 대한 설명으로 가장 올바른 것은?

- 보기
  - getBean 호출마다 새 인스턴스를 만든다.
  - 같은 컨테이너 내에서 동일 빈은 하나의 인스턴스로 관리된다.
  - 전역 정적 getInstance로만 접근해야 한다.
  - 항상 상태를 보관해도 안전하다.

**정답**: 같은 컨테이너 내에서 동일 빈은 하나의 인스턴스로 관리된다.

**해설**: 스프링의 기본 스코프는 싱글톤으로, 컨테이너가 하나의 인스턴스를 생성/공유합니다. 매 호출 신규 생성은 prototype 스코프이며, 정적 전역 접근은 스프링에서 권장되지 않습니다. 싱글톤은 공유되므로 내부 상태 보관은 동시성 문제를 유발할 수 있습니다.

#### 문제 3 (복수 응답)
**문제**: 싱글톤을 적용하거나 설계할 때의 올바른 접근을 모두 고르시오.

- 보기
  - 빈은 가능하면 무상태로 유지하고, 요청별 데이터는 지역 변수로 처리한다.
  - 전역 정적 접근을 선호하고 DI는 피한다.
  - 비용이 큰 리소스(ObjectMapper, 커넥션 풀 등)는 싱글톤 빈으로 공유한다.
  - 상태 공유가 필요하면 ThreadLocal을 무조건 사용한다.
  - 환경/프로필별로 다른 구현을 인터페이스 뒤에서 교체할 수 있게 설계한다.

**정답**: 빈은 가능하면 무상태로 유지, 비용이 큰 리소스 공유, 환경/프로필별 교체 가능 설계

**해설**:
- 무상태 설계는 공유 가변 상태로 인한 경쟁 조건을 줄입니다.
- ObjectMapper/커넥션 풀 등은 생성 비용이 크고 재사용성이 높아 싱글톤 공유가 적합합니다.
- 인터페이스 뒤에서 구현 교체(@Profile/@Conditional)는 전역 정적 접근보다 테스트/유연성 측면에서 우수합니다.
- 전역 정적 접근 선호는 테스트/치환을 어렵게 합니다.
- ThreadLocal은 누수/컨텍스트 전파 이슈가 있어 신중히, 한정된 상황에서만 사용해야 합니다.


---

<a id="02-1-어댑터-adapter"></a>

### 02-1. 어댑터 (Adapter)

#### 문제 1
**문제**: 어댑터 패턴의 핵심 의도로 가장 적절한 것은?

- 보기
  - 객체 생성 과정을 단계적으로 분리한다.
  - 서브클래싱으로 생성을 지연시킨다.
  - 호환되지 않는 인터페이스를 변환하여 재사용 가능하게 한다.
  - 동일한 제품군을 일관되게 생성한다.

**정답**: 호환되지 않는 인터페이스를 변환하여 재사용 가능하게 한다.

**해설**: 어댑터의 의도는 인터페이스 불일치를 해결해 기존 객체를 변경 없이 새 계약(Target)에 맞추는 것입니다. 단계적 생성/지연 생성/제품군 생성은 각각 빌더/팩토리 메서드/추상 팩토리의 관심사입니다.

#### 문제 2
**문제**: 다음 중 스프링에서 어댑터 패턴의 대표적 적용으로 가장 올바른 것은?

- 보기
  - BeanPostProcessor가 빈 초기화를 최적화한다.
  - HandlerAdapter가 다양한 컨트롤러를 DispatcherServlet 계약에 맞춘다.
  - @Transactional이 트랜잭션 경계를 관리한다.
  - ApplicationEventPublisher가 이벤트를 발행한다.

**정답**: HandlerAdapter가 다양한 컨트롤러를 DispatcherServlet 계약에 맞춘다.

**해설**: DispatcherServlet은 직접 컨트롤러 종류를 알지 않고, 여러 HandlerAdapter가 각기 다른 컨트롤러 스타일을 공통 계약으로 맞춰 실행합니다. 이는 전형적인 어댑터 구조입니다.

#### 문제 3 (복수 응답)
**문제**: 어댑터를 적용하기 좋은 상황을 모두 고르시오.

- 보기
  - 외부 결제/메일 SDK를 우리 도메인 계약에 맞춰야 할 때
  - 동일 도메인의 하위 타입을 상위 타입으로 업캐스팅할 때
  - 프레임워크가 요구하는 콜백 인터페이스에 레거시 객체를 연결해야 할 때
  - 외부 라이브러리 교체 가능성을 높이고 테스트 대체를 쉽게 하고 싶을 때
  - 단일 구현만 고정하여 영구적으로 변경하지 않으려 할 때

**정답**: 외부 SDK를 우리 계약에 맞춤, 프레임워크 콜백에 레거시 연결, 교체 가능성과 테스트 용이성 확보

**해설**:
- 외부 SDK/레거시를 표준 계약(Target)으로 감싸면 결합을 낮추고 도메인 모델을 보호할 수 있습니다.
- 프레임워크가 요구하는 콜백(예: DispatcherServlet-HandlerAdapter)에 기존 객체를 연결하는 것이 어댑터의 전형적 쓰임입니다.
- Target 뒤에서 여러 어댑터를 교체할 수 있어 벤더 교체/테스트 대체(목/스텁)가 쉬워집니다.
- 업캐스팅은 언어 기능으로 해결되므로 어댑터의 문제 영역이 아닙니다.
- 단일 구현을 고정하려는 목적은 어댑터의 장점을 활용하지 못합니다.


---

<a id="02-2-브리지-bridge"></a>

### 02-2. 브리지 (Bridge)

#### 문제 1
**문제**: 브리지 패턴의 핵심 의도로 가장 적절한 것은?

- 보기
  - 호환되지 않는 인터페이스를 변환해 재사용 가능하게 한다.
  - 추상과 구현을 분리해 각자 독립적으로 확장 가능하게 한다.
  - 동일 제품군 객체를 일관되게 생성한다.
  - 객체 생성을 단계적으로 분리하여 완성한다.

**정답**: 추상과 구현을 분리해 각자 독립적으로 확장 가능하게 한다.

**해설**: 브리지는 상속 대신 합성으로 추상(Abstraction)과 구현(Implementor)을 느슨하게 결합합니다. 두 축을 독립 확장할 수 있어 클래스 폭증을 방지합니다. 인터페이스 변환은 어댑터, 제품군 생성은 추상 팩토리, 단계적 생성은 빌더의 관심사입니다.

#### 문제 2
**문제**: 다음 중 스프링에서 브리지의 의도와 가장 잘 맞는 사례는?

- 보기
  - HandlerAdapter로 컨트롤러 호출 계약을 맞춘다.
  - Cache/CacheManager 추상 뒤에서 Caffeine/Redis 구현을 교체한다.
  - 프록시로 지연 로딩을 구현한다.
  - 템플릿 메서드로 하위 클래스에서 생성 훅을 결정한다.

**정답**: Cache/CacheManager 추상 뒤에서 Caffeine/Redis 구현을 교체한다.

**해설**: 스프링 캐시 추상화는 상위 계약(Cache/CacheManager)과 하위 구현(Caffeine/Redis 등)을 분리해 교체 가능성을 제공합니다. HandlerAdapter는 어댑터, 프록시는 지연/접근 제어, 템플릿 메서드는 생성 훅 결정과 관련이 깊습니다.

#### 문제 3 (복수 응답)
**문제**: 브리지를 적용하기 좋은 상황을 모두 고르시오.

- 보기
  - 상위 정책과 하위 기술을 각자 바꿔가며 조합해야 할 때
  - 구현 교체 가능성이 낮고 단일 상속만으로 충분할 때
  - 운영/테스트 환경에 따라 하위 리소스 접근 방식을 바꿔야 할 때
  - 상속 조합으로 클래스 수가 폭증할 것이 예상될 때
  - 동일 도메인 하위 타입을 상위 타입으로 업캐스팅할 때

**정답**: 상위 정책과 하위 기술을 각자 바꿔가며 조합, 운영/테스트별 하위 리소스 교체, 상속 조합 폭증 예상 시

**해설**:
- 추상/구현 2축을 독립적으로 바꿔가며 조합해야 할 때 브리지가 적합합니다.
- 환경에 따라 하위 구현(파일/클라우드 저장소, HTTP 클라이언트 등)을 교체하기 쉬워집니다.
- 상속만으로 조합을 표현하면 클래스가 폭증하므로, 합성 기반 브리지가 더 유지보수에 유리합니다.
- 업캐스팅은 언어 기능으로 해결되며 브리지의 문제 영역이 아닙니다.


---

<a id="02-3-컴포지트-composite"></a>

### 02-3. 컴포지트 (Composite)

#### 문제 1
**문제**: 컴포지트 패턴의 핵심 의도로 가장 적절한 것은?

- 보기
  - 호환되지 않는 인터페이스를 변환해 재사용 가능하게 한다.
  - 부분-전체 계층을 동일한 인터페이스로 다루게 한다.
  - 추상과 구현을 분리해 독립 확장을 가능하게 한다.
  - 객체 생성 과정을 단계적으로 분리한다.

**정답**: 부분-전체 계층을 동일한 인터페이스로 다루게 한다.

**해설**: 컴포지트는 Leaf와 Composite를 같은 상위 타입(Component)으로 다루어 트리 구조를 투명하게 사용하게 합니다. 인터페이스 변환은 어댑터, 추상/구현 분리는 브리지, 단계적 생성은 빌더에 해당합니다.

#### 문제 2
**문제**: 다음 중 스프링에서 컴포지트의 전형적 사례로 가장 적절한 것은?

- 보기
  - HandlerInterceptor 체인으로 요청을 전처리한다.
  - CompositePropertySource로 여러 PropertySource를 하나처럼 조회한다.
  - HandlerAdapter로 다양한 컨트롤러를 호출 계약에 맞춘다.
  - Proxy를 이용해 지연 로딩을 구현한다.

**정답**: CompositePropertySource로 여러 PropertySource를 하나처럼 조회한다.

**해설**: 여러 PropertySource를 내부에 보유하고 상위 타입처럼 동작하는 CompositePropertySource는 전형적인 컴포지트입니다. Interceptor 체인은 책임 연쇄, HandlerAdapter는 어댑터, Proxy는 접근 제어/지연과 관련이 큽니다.

#### 문제 3 (복수 응답)
**문제**: 컴포지트를 적용하기 좋은 상황을 모두 고르시오.

- 보기
  - 메뉴/카테고리와 같은 트리를 동일한 API로 렌더링해야 할 때
  - 단일 구현만 있고 트리 구조가 전혀 없을 때
  - 여러 상태 점검 컴포넌트를 하나의 상위 헬스로 묶어 노출해야 할 때
  - 하위 기술을 상위 정책과 독립적으로 교체해야 할 때
  - 여러 프로세서를 연결해 하나의 프로세서처럼 동작시키고 싶을 때

**정답**: 메뉴/카테고리 트리 렌더링, 여러 상태 점검을 상위 헬스로 묶기, 여러 프로세서를 연결해 하나처럼 동작

**해설**:
- UI/도메인 트리(메뉴/카테고리)를 동일한 인터페이스로 다루면 렌더/검증을 단순화할 수 있습니다.
- Actuator의 CompositeHealthContributor처럼 여러 헬스 컴포넌트를 상위로 묶어 노출하는 구조가 적합합니다.
- Spring Batch의 CompositeItemProcessor/Writer처럼 구성요소를 묶어 하나의 상위 타입으로 동작시키는 경우도 전형적입니다.
- 하위 기술을 상위 정책과 독립 교체는 브리지에 가깝고, 트리 구조가 전혀 없는 경우는 컴포지트의 이점을 활용하기 어렵습니다.


---

<a id="02-4-데코레이터-decorator"></a>

### 02-4. 데코레이터 (Decorator)

#### 문제 1
**문제**: 데코레이터 패턴의 핵심 의도로 가장 적절한 것은?

- 보기
  - 호환되지 않는 인터페이스를 변환해 재사용 가능하게 한다.
  - 객체에 새로운 책임을 동적으로 추가하되 동일한 인터페이스를 유지한다.
  - 추상과 구현을 분리해 독립적으로 확장한다.
  - 동일 제품군 객체를 일관되게 생성한다.

**정답**: 객체에 새로운 책임을 동적으로 추가하되 동일한 인터페이스를 유지한다.

**해설**: 데코레이터는 동일한 Component 계약을 구현하는 래퍼로 기존 객체를 감싼 뒤, 호출의 전후로 기능을 덧붙입니다. 인터페이스 변환은 어댑터, 추상/구현 분리는 브리지, 제품군 생성은 추상 팩토리의 관심사입니다.

#### 문제 2
**문제**: 다음 중 스프링에서 데코레이터의 대표적 적용으로 가장 올바른 것은?

- 보기
  - HandlerAdapter로 다양한 컨트롤러를 호출한다.
  - ContentCachingRequestWrapper로 HttpServletRequest를 감싸 바디 재사용을 가능하게 한다.
  - @Transactional로 트랜잭션 경계를 관리한다.
  - RestTemplate의 HttpMessageConverter를 통해 JSON을 변환한다.

**정답**: ContentCachingRequestWrapper로 HttpServletRequest를 감싸 바디 재사용을 가능하게 한다.

**해설**: ContentCachingRequestWrapper는 HttpServletRequest와 동일한 계약을 구현하며 내부 위임으로 원래 요청을 감싼 뒤, 바디 캐시 기능을 덧붙이는 전형적 데코레이터입니다. HandlerAdapter는 어댑터, @Transactional은 트랜잭션 관리, HttpMessageConverter는 인터페이스 변환(어댑터 성격)에 가깝습니다.

#### 문제 3 (복수 응답)
**문제**: 데코레이터를 적용하기 좋은 상황을 모두 고르시오.

- 보기
  - 기존 계약은 유지하면서 로깅/캐싱/검증 같은 부가 기능을 추가해야 할 때
  - 새로운 메서드를 추가해 인터페이스 자체를 바꿔야 할 때
  - 상속으로 조합이 폭증할 것이 예상될 때
  - 런타임 조건에 따라 기능을 켜고 끄며 조합해야 할 때
  - 타입 변환으로 호환되지 않는 인터페이스를 맞춰야 할 때

**정답**: 기존 계약 유지 + 부가 기능 추가, 상속 조합 폭증 예상 시, 런타임 조건에 따른 기능 조합

**해설**:
- 동일 인터페이스를 유지한 채 부가 기능(로깅, 캐싱, 검증, 메트릭 등)을 투명하게 추가하는 데 적합합니다.
- 상속으로 다양한 조합을 만들려면 클래스가 폭증하므로, 합성 기반의 데코레이터가 유리합니다.
- 실행 환경/설정에 따라 데코레이터를 켜고 끄면 유연한 구성이 가능합니다.
- 인터페이스 자체를 바꾸는 경우는 데코레이터보다 어댑터/인터페이스 리디자인이 필요합니다.
- 인터페이스 불일치 해결은 어댑터의 문제 영역입니다.


---

<a id="02-5-퍼사드-facade"></a>

### 02-5. 퍼사드 (Facade)

#### 문제 1
**문제**: 퍼사드 패턴의 핵심 의도로 가장 적절한 것은?

- 보기
  - 호환되지 않는 인터페이스를 변환해 재사용 가능하게 한다.
  - 복잡한 서브시스템을 감추고 단순한 고수준 인터페이스를 제공한다.
  - 추상과 구현을 분리해 독립 확장을 가능하게 한다.
  - 객체 생성 과정을 단계적으로 분리한다.

**정답**: 복잡한 서브시스템을 감추고 단순한 고수준 인터페이스를 제공한다.

**해설**: 퍼사드는 복잡한 내부 절차와 구성요소를 숨기고 사용하기 쉬운 진입점을 제공합니다. 인터페이스 변환은 어댑터, 추상/구현 분리는 브리지, 단계적 생성은 빌더의 관심사입니다.

#### 문제 2
**문제**: 다음 중 스프링에서 퍼사드의 전형적 사례로 가장 올바른 것은?

- 보기
  - HandlerAdapter가 다양한 컨트롤러를 공통 계약에 맞춘다.
  - JdbcTemplate이 JDBC 리소스 관리와 예외 변환을 감추고 간단한 메서드를 제공한다.
  - Proxy로 지연 로딩을 구현한다.
  - CompositePropertySource로 여러 소스를 하나처럼 조회한다.

**정답**: JdbcTemplate이 JDBC 리소스 관리와 예외 변환을 감추고 간단한 메서드를 제공한다.

**해설**: JdbcTemplate은 커넥션/스테이트먼트/해제/예외 변환을 묶어 고수준 API로 제공하는 퍼사드입니다. HandlerAdapter는 어댑터, Proxy는 접근 제어/지연, CompositePropertySource는 컴포지트에 가깝습니다.

#### 문제 3 (복수 응답)
**문제**: 퍼사드를 적용하기 좋은 상황을 모두 고르시오.

- 보기
  - 컨트롤러가 여러 하위 서비스를 순서대로 호출해야 할 때 이를 단순화하고 싶다.
  - 저수준 API의 보일러플레이트(리소스/예외)를 숨기고 싶다.
  - 인터페이스 불일치를 해결해 타입을 변환해야 한다.
  - 도메인 유스케이스를 한 메서드로 제공해 외부 호출을 단순화하고 싶다.
  - 부분-전체 트리를 동일 인터페이스로 다뤄야 한다.

**정답**: 컨트롤러의 순차 호출 단순화, 저수준 보일러플레이트 숨기기, 유스케이스 단일 메서드 제공

**해설**:
- 컨트롤러에서 여러 서비스를 순서대로 호출하는 복잡도를 퍼사드가 캡슐화하면 호출부가 단순해집니다.
- 리소스 관리/예외 변환 등 보일러플레이트를 퍼사드(템플릿)로 감추면 생산성과 안정성이 올라갑니다.
- 도메인 유스케이스를 안정된 퍼사드 메서드로 제공하면 외부 호출자가 절차를 몰라도 됩니다.
- 인터페이스 불일치 해결은 어댑터의 문제이며, 부분-전체는 컴포지트에 해당합니다.


---

<a id="02-6-플라이웨이트-flyweight"></a>

### 02-6. 플라이웨이트 (Flyweight)

#### 문제 1
**문제**: 플라이웨이트 패턴의 핵심 아이디어로 가장 적절한 것은?

- 보기
  - 상속으로 기능을 확장해 조합을 줄인다.
  - 동일한 내재 상태를 공유하고 외재 상태는 호출 시 제공한다.
  - 복잡한 서브시스템을 단순 인터페이스로 감춘다.
  - 호환되지 않는 인터페이스를 변환한다.

**정답**: 동일한 내재 상태를 공유하고 외재 상태는 호출 시 제공한다.

**해설**: 플라이웨이트의 본질은 불변의 공통 상태(내재)를 객체 내부에 보관해 공유하고, 요청마다 달라지는 맥락(외재)을 인자로 전달하는 것입니다. 상속 조합 축소는 데코레이터/브리지의 맥락이며, 서브시스템 단순화는 퍼사드, 인터페이스 변환은 어댑터의 관심사입니다.

#### 문제 2
**문제**: 다음 중 플라이웨이트의 적용으로 보기 가장 적절한 것은?

- 보기
  - 요청마다 새로운 MediaType("application/json") 객체를 생성해 사용한다.
  - 같은 정규식을 매번 Pattern.compile로 생성한다.
  - HttpStatus 같은 enum 인스턴스를 전역에서 공유한다.
  - 매 요청마다 다른 내재 상태를 가진 가변 객체를 재사용한다.

**정답**: HttpStatus 같은 enum 인스턴스를 전역에서 공유한다.

**해설**: enum은 각 상수당 단일 인스턴스를 전역 공유합니다(플라이웨이트의 전형). MediaType/Pattern을 매번 새로 생성하는 것은 비효율적이며, 내재 상태가 다른 가변 객체 재사용은 안전하지 않습니다.

#### 문제 3 (복수 응답)
**문제**: 플라이웨이트를 적용하기 좋은 상황을 모두 고르시오.

- 보기
  - 동일 의미의 불변 값을 매우 자주 생성하는 경우
  - 각 객체가 서로 다른 가변 내부 상태를 강하게 보유해야 하는 경우
  - 템플릿을 캐시해 반복 렌더링 비용을 줄이고 싶은 경우
  - 아이콘/글리프 등 리소스를 여러 위치에 표시하되 픽셀 데이터는 공유하고 싶은 경우
  - 외재 상태를 전달하기 어렵고, 객체가 내부에 모든 상태를 들고 있어야만 하는 경우

**정답**: 동일 의미의 불변 값 잦은 생성, 템플릿 캐시로 반복 렌더링 절감, 아이콘/글리프 픽셀 데이터 공유

**해설**:
- 불변 값(예: MediaType, DateTimeFormatter 등)을 자주 생성한다면 캐시/공유로 메모리·생성 비용을 줄일 수 있습니다.
- 템플릿의 컴파일 결과(내재)를 공유하고, 모델 데이터(외재)를 호출 시 주입하면 효율적입니다.
- 아이콘/글리프의 픽셀 데이터(내재)를 공유하고 위치·색상 등은 외재로 전달합니다.
- 강한 가변 내부 상태를 유지해야 하거나 외재 전달이 어려운 경우는 플라이웨이트에 부적합합니다.


---

<a id="02-7-프록시-proxy"></a>

### 02-7. 프록시 (Proxy)

#### 문제 1
**문제**: 프록시 패턴의 핵심 의도로 가장 적절한 것은?

- 보기
  - 호환되지 않는 인터페이스를 변환해 재사용 가능하게 한다.
  - 객체에 새로운 책임을 동적으로 추가하되 동일한 인터페이스를 유지한다.
  - 다른 객체에 대한 접근을 제어하거나 부가 기능을 투명하게 제공하기 위해 대리한다.
  - 복잡한 서브시스템을 단순한 고수준 인터페이스로 감춘다.

**정답**: 다른 객체에 대한 접근을 제어하거나 부가 기능을 투명하게 제공하기 위해 대리한다.

**해설**: 프록시는 같은 Subject 계약을 구현한 대리 객체로, 호출 전후에 접근 제어/트랜잭션/캐시/지연 로딩 등을 수행합니다. 인터페이스 변환은 어댑터, 동적 책임 추가는 데코레이터, 서브시스템 단순화는 퍼사드의 의도입니다.

#### 문제 2
**문제**: 다음 중 스프링에서 "프록시" 기반으로 동작하는 것으로 가장 올바른 것은?

- 보기
  - @Transactional을 통한 트랜잭션 경계 적용
  - HttpMessageConverter를 통한 JSON 직렬화/역직렬화
  - CompositePropertySource를 통한 속성 조회
  - ContentCachingRequestWrapper로 요청 바디 캐싱

**정답**: @Transactional을 통한 트랜잭션 경계 적용

**해설**: 스프링은 @Transactional 메서드 호출을 프록시가 가로채 트랜잭션을 시작/종료합니다. HttpMessageConverter는 어댑터 성격, CompositePropertySource는 컴포지트, ContentCachingRequestWrapper는 데코레이터에 가깝습니다.

#### 문제 3 (복수 응답)
**문제**: 프록시를 적용하기 좋은 상황을 모두 고르시오.

- 보기
  - 레이트 리미트나 서킷 브레이커로 외부 호출을 보호해야 할 때
  - 인터페이스 불일치로 타입을 변환해야 할 때
  - 권한 검사/감사 로깅을 서비스 경계에서 일관되게 적용하고 싶을 때
  - 엔티티 연관을 지연 로딩해 성능을 최적화하고 싶을 때
  - 동일한 트리 구조를 동일 인터페이스로 다뤄야 할 때

**정답**: 레이트 리미트나 서킷 브레이커로 외부 호출 보호, 권한 검사/감사 로깅의 일관 적용, 엔티티 연관 지연 로딩

**해설**:
- 외부 호출 보호: 프록시에서 호출 전 레이트 리미트/서킷 브레이커/리트라이 정책을 적용하기 적합합니다.
- 보안/감사: 서비스 경계에서 인가 검사/감사 로깅을 투명하게 적용할 수 있습니다.
- 지연 로딩: 가상 프록시로 실제 데이터를 필요 시점까지 미룹니다(JPA 연관 프록시 등).
- 인터페이스 불일치 해결은 어댑터, 트리 구조 통일은 컴포지트의 문제 영역입니다.


---

<a id="03-1-책임-연쇄-chain-of-responsibility"></a>

### 03-1. 책임 연쇄 (Chain of Responsibility)

#### 문제 1
**문제**: 책임 연쇄 패턴의 핵심 의도에 가장 가까운 설명은?

- 보기
  - 동일한 인터페이스를 유지한 채 객체에 동적으로 책임을 추가한다.
  - 요청을 일렬의 처리자에게 전달하여 처리 가능자가 맡고, 불가하면 다음으로 위임한다.
  - 복잡한 서브시스템을 단순한 고수준 인터페이스로 감춘다.
  - 객체 생성 과정을 단계별로 분리하고 다양한 표현을 가능하게 한다.

**정답**: 요청을 일렬의 처리자에게 전달하여 처리 가능자가 맡고, 불가하면 다음으로 위임한다.

**해설**: 책임 연쇄(CoR)는 처리자들이 연결된 체인을 따라 요청을 전달하며, 어떤 처리자가 책임을 질 수 있으면 처리하고 아니면 다음으로 넘깁니다. 동적 책임 추가는 데코레이터, 서브시스템 단순화는 퍼사드, 단계별 생성은 빌더의 의도입니다.

#### 문제 2
**문제**: 다음 중 스프링에서 "체인"으로 동작하는 구성요소로 가장 적절한 것은?

- 보기
  - JdbcTemplate의 RowMapper 목록
  - Spring MVC HandlerInterceptor 목록
  - @Transactional AOP 포인트컷 목록
  - ObjectMapper의 Module 등록 목록

**정답**: Spring MVC HandlerInterceptor 목록

**해설**: HandlerInterceptor는 preHandle → postHandle → afterCompletion의 순서로 체인처럼 호출되며, preHandle이 false를 반환하면 체인을 단락합니다. RowMapper/Module 목록은 체인 규약이 없고, @Transactional 포인트컷은 매칭 규칙이지 순차 처리 체인이 아닙니다.

#### 문제 3 (복수 응답)
**문제**: 책임 연쇄를 적용하기 좋은 상황을 모두 고르시오.

- 보기
  - 인증/인가, 입력 검증, 로깅을 단계별로 통과시키고 싶을 때
  - 호환되지 않는 인터페이스를 어댑터로 변환해야 할 때
  - 여러 예외 처리 전략을 순서대로 시도해 첫 성공으로 종료하고 싶을 때
  - 동일한 요청을 모든 처리자가 반드시 처리해야 할 때
  - 할인 규칙/쿠폰 적용 순서를 유연하게 조합하고 싶을 때

**정답**: 인증/인가\, 입력 검증\, 로깅 단계 통과; 예외 처리 전략의 순차 시도; 할인 규칙/쿠폰 적용 순서 조합

**해설**:
- 인증/검증/로깅 등은 각 책임을 분리한 체인 단계로 구성해 재사용과 순서 제어가 용이합니다.
- 여러 예외 해결기를 순서대로 시도하여 첫 성공에서 단락하는 구조는 전형적 CoR입니다.
- 할인/쿠폰 규칙을 순차적으로 평가하며 조건에 따라 적용/단락하는 파이프라인도 CoR에 적합합니다.
- 어댑터는 인터페이스 호환 문제이며, "모든 처리자가 반드시 처리"해야 하는 파이프라인은 CoR의 단락 특성과 맞지 않습니다.



---

<a id="03-2-커맨드-command"></a>

### 03-2. 커맨드 (Command)

#### 문제 1
**문제**: 커맨드 패턴의 핵심 의도로 가장 적절한 것은?

- 보기
  - 호환되지 않는 인터페이스를 변환해 재사용 가능하게 한다.
  - 요청을 객체로 캡슐화해 호출자와 수신자의 결합을 느슨하게 한다.
  - 동일한 인터페이스를 유지한 채 객체에 동적으로 책임을 추가한다.
  - 복잡한 서브시스템을 단순한 고수준 인터페이스로 감춘다.

**정답**: 요청을 객체로 캡슐화해 호출자와 수신자의 결합을 느슨하게 한다.

**해설**: 커맨드는 요청을 Command 객체로 캡슐화해 호출 시점/방식을 분리합니다. 이로써 큐잉, 로깅, 재시도, undo 같은 부가기능을 유연하게 추가할 수 있습니다. 인터페이스 변환은 어댑터, 동적 책임 추가는 데코레이터, 서브시스템 단순화는 퍼사드의 의도입니다.

#### 문제 2
**문제**: 다음 중 스프링/자바에서 커맨드 패턴의 성격과 가장 거리가 먼 것은?

- 보기
  - Executor에 제출되는 Runnable/Callable 작업
  - Spring Batch의 Tasklet 작업 단위
  - Spring MVC의 HandlerInterceptor 체인 자체
  - 메시지를 받아 처리하는 메시지 핸들러

**정답**: Spring MVC의 HandlerInterceptor 체인 자체

**해설**: Runnable/Callable, Batch Tasklet, 메시지 핸들러는 각각 실행 가능한 요청을 객체로 다루므로 커맨드 성격이 강합니다. 반면 HandlerInterceptor 체인은 요청을 단계별로 통과/단락하는 책임 연쇄(CoR)에 가깝습니다.

#### 문제 3 (복수 응답)
**문제**: 커맨드 패턴을 적용하기 좋은 상황을 모두 고르시오.

- 보기
  - 버튼/엔드포인트 동작을 객체로 캡슐화해 로깅·권한·트랜잭션을 일괄 적용할 때
  - 요청을 큐에 저장해 재시도/스케줄 실행이 필요할 때
  - 인터페이스 불일치를 해결해 타입을 변환해야 할 때
  - 되돌리기(undo)나 매크로 명령이 요구될 때
  - 동일한 트리 구조를 동일 인터페이스로 다뤄야 할 때

**정답**: 버튼/엔드포인트 캡슐화 및 공통 정책 적용; 요청 큐 저장과 재시도/스케줄 실행; 되돌리기(undo)나 매크로 명령 요구

**해설**:
- UI/API 동작을 Command로 만들면 감사/권한/트랜잭션/리트라이를 공통 Invoker에서 일괄 적용하기 쉽습니다.
- 큐잉/스케줄링/재시도는 요청의 독립적 저장·재실행이 핵심으로 커맨드가 적합합니다.
- undo/매크로는 명령 이력·조합을 다루므로 전형적인 커맨드 활용처입니다.
- 인터페이스 불일치 해결은 어댑터, 트리 구조 통합은 컴포지트의 문제 영역입니다.


---

<a id="03-3-인터프리터-interpreter"></a>

### 03-3. 인터프리터 (Interpreter)

#### 문제 1
**문제**: 인터프리터 패턴의 핵심 의도로 가장 적절한 것은?

- 보기
  - 객체에 새로운 책임을 동적으로 추가한다.
  - 도메인 전용 언어의 문장을 해석해 의미를 계산한다.
  - 호환되지 않는 인터페이스를 변환한다.
  - 복잡한 서브시스템을 단순한 고수준 인터페이스로 감춘다.

**정답**: 도메인 전용 언어의 문장을 해석해 의미를 계산한다.

**해설**: 인터프리터는 DSL/표현식으로 작성된 문장을 파싱해 AST를 만들고, 각 노드가 컨텍스트를 바탕으로 의미를 계산합니다. 동적 책임 추가는 데코레이터, 인터페이스 변환은 어댑터, 서브시스템 단순화는 퍼사드의 의도입니다.

#### 문제 2
**문제**: 다음 중 스프링에서 인터프리터의 적용 사례로 가장 적절한 것은?

- 보기
  - BeanPostProcessor로 라이프사이클 훅을 연결한다.
  - @PreAuthorize("hasRole('ADMIN') and #id == principal.id") 같은 표현식을 평가한다.
  - @Transactional로 트랜잭션 경계를 적용한다.
  - RestTemplate로 외부 API를 호출한다.

**정답**: @PreAuthorize("hasRole('ADMIN') and #id == principal.id") 같은 표현식을 평가한다.

**해설**: Spring Security/SpEL은 표현식을 파싱해 AST를 만들고 현재 Authentication/빈 컨텍스트를 입력으로 평가합니다. BeanPostProcessor는 생명주기 훅, @Transactional은 프록시 기반 AOP, RestTemplate은 HTTP 클라이언트입니다.

#### 문제 3 (복수 응답)
**문제**: 다음 중 간단한 규칙 DSL을 설계해 인터프리터로 해석하기 좋은 상황을 모두 고르시오.

- 보기
  - 할인 정책을 금액/등급/시간대 조건으로 유연하게 바꾸고 싶을 때
  - URL 경로 패턴 매칭을 커스터마이징해야 할 때
  - 동일한 트리 구조를 동일 인터페이스로 다뤄야 할 때
  - 기능 플래그를 조건식으로 제어하고 배포 없이 전환하고 싶을 때
  - 여러 데이터 소스를 통합한 퍼사드 API를 만들 때

**정답**: 할인 정책 유연 변경, 기능 플래그 조건식 제어, URL 경로 패턴 매칭 커스터마이징

**해설**:
- 할인/요금/정책 규칙은 선언적 조건을 텍스트로 외부화해 AST로 해석하기 적합합니다.
- 기능 플래그를 조건식(역할ㆍ시간ㆍ트래픽)에 따라 켜고 끄는 로직도 DSL로 표현하기 좋습니다.
- URL 패턴 매칭은 제한된 문법을 해석해 매칭을 수행하는 인터프리터적 사례입니다.
- 동일 트리 구조는 컴포지트의 문제 영역이고, 퍼사드 API 통합은 인터프리터와 직접 관련이 없습니다.


---

<a id="03-4-반복자-iterator"></a>

### 03-4. 반복자 (Iterator)

#### 문제 1
**문제**: 반복자 패턴의 핵심 의도에 가장 가까운 것은?

- 보기
  - 객체 생성 과정을 단계별로 분리한다.
  - 집합체의 내부 표현을 노출하지 않고 요소에 순차적으로 접근할 수 있게 한다.
  - 동일한 인터페이스를 유지한 채 객체에 동적으로 책임을 추가한다.
  - 복잡한 서브시스템을 단순한 고수준 인터페이스로 감춘다.

**정답**: 집합체의 내부 표현을 노출하지 않고 요소에 순차적으로 접근할 수 있게 한다.

**해설**: Iterator는 hasNext/next 같은 계약을 통해 요소 접근을 통일하고, 배열/연결 리스트/원격 커서 등 내부 표현을 감춥니다. 단계적 생성은 빌더, 동적 책임 추가는 데코레이터, 서브시스템 단순화는 퍼사드의 의도입니다.

#### 문제 2
**문제**: 다음 중 자바/스프링에서 반복자(혹은 그 변형) 개념과 가장 거리가 먼 것은?

- 보기
  - Iterable/Iterator를 통한 for-each 순회
  - Spring Data Slice/Page를 이용한 페이지 네비게이션
  - JDBC ResultSet의 next() 반복과 RowMapper 매핑
  - 퍼사드(Facade)로 하위 서브시스템을 감싸는 API 설계

**정답**: 퍼사드(Facade)로 하위 서브시스템을 감싸는 API 설계

**해설**: Iterable/Iterator, Slice/Page, ResultSet.next()는 모두 요소를 순차 접근하는 반복 모델과 관련 있습니다. 퍼사드는 복잡한 서브시스템을 단순 인터페이스 뒤로 숨기는 구조 패턴으로 반복자와 별개입니다.

#### 문제 3 (복수 응답)
**문제**: 반복자 패턴을 적용하거나 고려하기 좋은 상황을 모두 고르시오.

- 보기
  - 대용량 목록을 커서나 배치 단위로 순회해야 할 때
  - 내부 표현을 숨긴 채 일관된 순회 인터페이스를 제공해야 할 때
  - 인터페이스 불일치를 변환해야 할 때
  - 무한 스크롤/스트리밍 처리가 필요할 때
  - 동일한 트리 구조를 동일 인터페이스로 다뤄야 할 때

**정답**: 대용량 목록의 커서/배치 순회, 내부 표현 은닉·일관된 순회 인터페이스 제공, 무한 스크롤/스트리밍 처리

**해설**:
- 커서/배치 순회: 메모리 사용을 통제하며 순차 접근하기 좋아 Iterator 철학에 맞습니다.
- 내부 표현 은닉: 집합체 구현과 무관하게 동일 인터페이스로 순회합니다.
- 무한 스크롤/스트리밍: 다음 요소의 존재 여부와 점진적 처리라는 반복자 성격이 요구됩니다.
- 인터페이스 불일치 해결은 어댑터, 트리 구조 통합은 컴포지트의 관심사입니다.
