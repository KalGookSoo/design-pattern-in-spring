# 정답 및 해설

이 문서는 각 장의 확인 문제에 대한 정답과 해설을 제공합니다.

## 목차

### 01. 생성 패턴 (Creational Patterns)
- 01-1. [추상 팩토리 (Abstract Factory)](#01-1-추상-팩토리-abstract-factory)
- 01-2. [빌더 (Builder)](#01-2-빌더-builder)
- 01-3. 팩토리 메서드 (Factory Method)
- 01-4. 프로토타입 (Prototype)
- 01-5. 싱글톤 (Singleton)

### 02. 구조 패턴 (Structural Patterns)
- 02-1. 어댑터 (Adapter)
- 02-2. 브리지 (Bridge)
- 02-3. 컴포지트 (Composite)
- 02-4. 데코레이터 (Decorator)
- 02-5. 퍼사드 (Facade)
- 02-6. 플라이웨이트 (Flyweight)
- 02-7. 프록시 (Proxy)

### 03. 행위 패턴 (Behavioral Patterns)
- 03-1. 책임 연쇄 (Chain of Responsibility)
- 03-2. 커맨드 (Command)
- 03-3. 인터프리터 (Interpreter)
- 03-4. 반복자 (Iterator)
- 03-5. 중재자 (Mediator)
- 03-6. 메멘토 (Memento)
- 03-7. 옵저버 (Observer)
- 03-8. 상태 (State)
- 03-9. 전략 (Strategy)
- 03-10. 템플릿 메서드 (Template Method)
- 03-11. 방문자 (Visitor)




---

<a id="01-1-추상-팩토리-abstract-factory"></a>

### 01-1. 추상 팩토리 (Abstract Factory)

#### 문제 1
**문제**: 추상 팩토리 패턴의 주된 목적은 무엇인가?

- 보기
  - 객체 생명주기 전체(생성-사용-소멸)를 강제한다.
  - 관련 객체들의 일관된 세트를 생성하되, 구체 클래스를 감춘다.
  - 객체의 내부 상태를 캡슐화하고 복구한다.
  - 요청을 캡슐화하여 서로 다른 큐에 전달한다.

**정답**: 관련 객체들의 일관된 세트를 생성하되, 구체 클래스를 감춘다.

**해설**: 추상 팩토리는 서로 호환되는 제품군(예: 버튼·체크박스)을 한 번에 생성하게 해 일관성을 보장하고, 클라이언트가 구체 클래스를 알 필요 없이 인터페이스에만 의존하도록 만든다. 생명주기 관리나 상태 복구, 요청 캡슐화는 각각 다른 패턴(예: 템플릿 메서드/메멘토/커맨드)에 해당한다.

#### 문제 2
**문제**: 다음 중 스프링에서 추상 팩토리와 가장 밀접한 구성요소는 무엇인가?

- 보기
  - HandlerInterceptor
  - ApplicationContext/BeanFactory
  - RestTemplate
  - ViewResolver만 단독으로 사용

**정답**: ApplicationContext/BeanFactory

**해설**: 스프링 컨테이너는 설정과 조건(프로필, @Conditional 등)에 따라 구현체를 선택해 빈을 생성·주입한다. 이는 추상 팩토리처럼 “구체 타입 선택과 생성”을 캡슐화하는 동작과 동일한 핵심을 가진다. Interceptor/RestTemplate/ViewResolver는 각각 특정 관심사의 컴포넌트일 뿐, 제품군 생성 추상화와는 직접적이지 않다.

#### 문제 3 (복수 응답)
**문제**: 다음 중 추상 팩토리 패턴을 적용하기 좋은 경우를 모두 고르시오.

- 보기
  - 플랫폼(웹/모바일)에 따라 UI 컴포넌트 세트가 달라지는 경우
  - 데이터 접근 기술(JPA/JDBC)에 따라 리포지토리 구현군이 달라지는 경우
  - 단일 클래스 인스턴스 하나만 필요하고 변형이 없는 경우
  - 멀티 테넌트 환경에서 테넌트별 브랜드/테마 컴포넌트 세트가 다른 경우
  - 동일한 구현체를 영구적으로 고정해야 하는 경우

**정답**: 플랫폼(웹/모바일), 데이터 접근 기술(JPA/JDBC), 멀티 테넌트별 테마 구성

**해설**:
- 플랫폼별 UI는 버튼/체크박스/아이콘 등 호환되는 컴포넌트 “제품군”을 일관되게 교체해야 하므로 적합하다.
- 데이터 접근 기술별로 JPA/Mongo/JDBC 리포지토리 구현군이 달라지는 경우, 동일한 리포지토리 인터페이스를 유지하면서 팩토리로 제품군을 선택할 수 있다.
- 멀티 테넌트 환경에서 테넌트별 테마/브랜딩 컴포넌트 세트를 교체해야 하므로 추상 팩토리로 일관된 교체가 가능하다.
- 단일 클래스만 필요하거나 구현체를 고정해야 하는 경우는 추상 팩토리의 장점(교체/일관된 세트 생성)을 활용하지 못하므로 부적절하다.

# 정답 및 해설

이 문서는 각 장의 확인 문제에 대한 정답과 해설을 제공합니다.

## 목차

### 01. 생성 패턴 (Creational Patterns)
- 01-1. [추상 팩토리 (Abstract Factory)](#01-1-추상-팩토리-abstract-factory)
- 01-2. [빌더 (Builder)](#01-2-빌더-builder)
- 01-3. 팩토리 메서드 (Factory Method)
- 01-4. 프로토타입 (Prototype)
- 01-5. 싱글톤 (Singleton)

### 02. 구조 패턴 (Structural Patterns)
- 02-1. 어댑터 (Adapter)
- 02-2. 브리지 (Bridge)
- 02-3. 컴포지트 (Composite)
- 02-4. 데코레이터 (Decorator)
- 02-5. 퍼사드 (Facade)
- 02-6. 플라이웨이트 (Flyweight)
- 02-7. 프록시 (Proxy)

### 03. 행위 패턴 (Behavioral Patterns)
- 03-1. 책임 연쇄 (Chain of Responsibility)
- 03-2. 커맨드 (Command)
- 03-3. 인터프리터 (Interpreter)
- 03-4. 반복자 (Iterator)
- 03-5. 중재자 (Mediator)
- 03-6. 메멘토 (Memento)
- 03-7. 옵저버 (Observer)
- 03-8. 상태 (State)
- 03-9. 전략 (Strategy)
- 03-10. 템플릿 메서드 (Template Method)
- 03-11. 방문자 (Visitor)




---

<a id="01-1-추상-팩토리-abstract-factory"></a>

### 01-1. 추상 팩토리 (Abstract Factory)

#### 문제 1
**문제**: 추상 팩토리 패턴의 주된 목적은 무엇인가?

- 보기
  - 객체 생명주기 전체(생성-사용-소멸)를 강제한다.
  - 관련 객체들의 일관된 세트를 생성하되, 구체 클래스를 감춘다.
  - 객체의 내부 상태를 캡슐화하고 복구한다.
  - 요청을 캡슐화하여 서로 다른 큐에 전달한다.

**정답**: 관련 객체들의 일관된 세트를 생성하되, 구체 클래스를 감춘다.

**해설**: 추상 팩토리는 서로 호환되는 제품군(예: 버튼·체크박스)을 한 번에 생성하게 해 일관성을 보장하고, 클라이언트가 구체 클래스를 알 필요 없이 인터페이스에만 의존하도록 만든다. 생명주기 관리나 상태 복구, 요청 캡슐화는 각각 다른 패턴(예: 템플릿 메서드/메멘토/커맨드)에 해당한다.

#### 문제 2
**문제**: 다음 중 스프링에서 추상 팩토리와 가장 밀접한 구성요소는 무엇인가?

- 보기
  - HandlerInterceptor
  - ApplicationContext/BeanFactory
  - RestTemplate
  - ViewResolver만 단독으로 사용

**정답**: ApplicationContext/BeanFactory

**해설**: 스프링 컨테이너는 설정과 조건(프로필, @Conditional 등)에 따라 구현체를 선택해 빈을 생성·주입한다. 이는 추상 팩토리처럼 “구체 타입 선택과 생성”을 캡슐화하는 동작과 동일한 핵심을 가진다. Interceptor/RestTemplate/ViewResolver는 각각 특정 관심사의 컴포넌트일 뿐, 제품군 생성 추상화와는 직접적이지 않다.

#### 문제 3 (복수 응답)
**문제**: 다음 중 추상 팩토리 패턴을 적용하기 좋은 경우를 모두 고르시오.

- 보기
  - 플랫폼(웹/모바일)에 따라 UI 컴포넌트 세트가 달라지는 경우
  - 데이터 접근 기술(JPA/JDBC)에 따라 리포지토리 구현군이 달라지는 경우
  - 단일 클래스 인스턴스 하나만 필요하고 변형이 없는 경우
  - 멀티 테넌트 환경에서 테넌트별 브랜드/테마 컴포넌트 세트가 다른 경우
  - 동일한 구현체를 영구적으로 고정해야 하는 경우

**정답**: 플랫폼(웹/모바일), 데이터 접근 기술(JPA/JDBC), 멀티 테넌트별 테마 구성

**해설**:
- 플랫폼별 UI는 버튼/체크박스/아이콘 등 호환되는 컴포넌트 “제품군”을 일관되게 교체해야 하므로 적합하다.
- 데이터 접근 기술별로 JPA/Mongo/JDBC 리포지토리 구현군이 달라지는 경우, 동일한 리포지토리 인터페이스를 유지하면서 팩토리로 제품군을 선택할 수 있다.
- 멀티 테넌트 환경에서 테넌트별 테마/브랜딩 컴포넌트 세트를 교체해야 하므로 추상 팩토리로 일관된 교체가 가능하다.
- 단일 클래스만 필요하거나 구현체를 고정해야 하는 경우는 추상 팩토리의 장점(교체/일관된 세트 생성)을 활용하지 못하므로 부적절하다.


---

<a id="01-2-빌더-builder"></a>

### 01-2. 빌더 (Builder)

#### 문제 1
**문제**: 빌더 패턴의 핵심 아이디어로 가장 적절한 것은?

- 보기
  - 구체 팩토리별로 일관된 제품군을 생성한다.
  - 객체의 내부 상태를 스냅샷으로 저장하고 복구한다.
  - 복잡한 객체 생성을 단계별로 분리하고 최종 단계에서 완성한다.
  - 알고리즘의 골격을 정의하고 하위 클래스가 일부 단계를 재정의한다.

**정답**: 복잡한 객체 생성을 단계별로 분리하고 최종 단계에서 완성한다.

**해설**: 빌더는 많은 선택적 인자나 조건부 조립이 필요한 경우에 적합하며, 생성 과정을 단계별로 나누어 가독성과 안전성을 높인다. 템플릿 메서드/메멘토/추상 팩토리 등의 의도와는 다르다.

#### 문제 2
**문제**: 다음 중 스프링에서 "빌더" 스타일 API로 분류되기 어려운 것은?

- 보기
  - RestTemplateBuilder
  - WebClient.Builder
  - UriComponentsBuilder
  - JdbcTemplate 자체(쿼리 실행 도우미)

**정답**: JdbcTemplate 자체(쿼리 실행 도우미)

**해설**: JdbcTemplate은 쿼리 실행을 돕는 템플릿 유틸리티로, 최종 객체를 단계적으로 구성해 build()로 완성하는 전형적 빌더와는 성격이 다르다. 나머지는 모두 객체를 체이닝 설정 후 build() 혹은 toUri 등으로 생성한다.

#### 문제 3 (복수 응답)
**문제**: 빌더 패턴을 적용하기 좋은 경우를 모두 고르시오.

- 보기
  - 선택적 인자가 많은 불변 설정 객체를 만들 때
  - HTTP 클라이언트 구성 옵션(타임아웃/헤더/리트라이 등)을 단계적으로 설정할 때
  - 단일 생성자에 인자가 1~2개뿐인 단순 값 객체를 만들 때
  - 동일 절차로 프로파일별 다른 프리셋을 손쉽게 만들고 싶을 때
  - 런타임에 객체 제품군의 일관성을 강제하고 싶을 때

**정답**: 선택적 인자가 많은 불변 설정 객체, HTTP 클라이언트 구성, 프로파일별 프리셋 구성

**해설**:
- 불변 설정 객체에 선택적 속성이 많으면 빌더로 누락/순서 오류를 줄일 수 있다.
- HTTP 클라이언트는 옵션이 다양해 단계적 설정과 최종 build가 적합하다.
- 프로파일별 프리셋은 동일 절차로 다른 결과를 생성하므로 빌더의 장점이 크다.
- 인자가 매우 적은 단순 객체, 혹은 제품군 일관성 강제(이는 추상 팩토리의 관심사)는 빌더와 맞지 않는다.
