# 정답 및 해설

이 문서는 각 장의 확인 문제에 대한 정답과 해설을 제공합니다.

## 목차

### 01. 생성 패턴 (Creational Patterns)
- 01-1. [추상 팩토리 (Abstract Factory)](#01-1-추상-팩토리-abstract-factory)
- 01-2. [빌더 (Builder)](#01-2-빌더-builder)
- 01-3. 팩토리 메서드 (Factory Method)
- 01-4. 프로토타입 (Prototype)
- 01-5. 싱글톤 (Singleton)

### 02. 구조 패턴 (Structural Patterns)
- 02-1. 어댑터 (Adapter)
- 02-2. 브리지 (Bridge)
- 02-3. 컴포지트 (Composite)
- 02-4. 데코레이터 (Decorator)
- 02-5. 퍼사드 (Facade)
- 02-6. 플라이웨이트 (Flyweight)
- 02-7. 프록시 (Proxy)

### 03. 행위 패턴 (Behavioral Patterns)
- 03-1. 책임 연쇄 (Chain of Responsibility)
- 03-2. 커맨드 (Command)
- 03-3. 인터프리터 (Interpreter)
- 03-4. 반복자 (Iterator)
- 03-5. 중재자 (Mediator)
- 03-6. 메멘토 (Memento)
- 03-7. 옵저버 (Observer)
- 03-8. 상태 (State)
- 03-9. 전략 (Strategy)
- 03-10. 템플릿 메서드 (Template Method)
- 03-11. 방문자 (Visitor)




---

<a id="01-1-추상-팩토리-abstract-factory"></a>

### 01-1. 추상 팩토리 (Abstract Factory)

#### 문제 1
**문제**: 추상 팩토리 패턴의 주된 목적은 무엇인가?

- 보기
  - 객체 생명주기 전체(생성-사용-소멸)를 강제한다.
  - 관련 객체들의 일관된 세트를 생성하되, 구체 클래스를 감춘다.
  - 객체의 내부 상태를 캡슐화하고 복구한다.
  - 요청을 캡슐화하여 서로 다른 큐에 전달한다.

**정답**: 관련 객체들의 일관된 세트를 생성하되, 구체 클래스를 감춘다.

**해설**: 추상 팩토리는 서로 호환되는 제품군(예: 버튼·체크박스)을 한 번에 생성하게 해 일관성을 보장하고, 클라이언트가 구체 클래스를 알 필요 없이 인터페이스에만 의존하도록 만든다. 생명주기 관리나 상태 복구, 요청 캡슐화는 각각 다른 패턴(예: 템플릿 메서드/메멘토/커맨드)에 해당한다.

#### 문제 2
**문제**: 다음 중 스프링에서 추상 팩토리와 가장 밀접한 구성요소는 무엇인가?

- 보기
  - HandlerInterceptor
  - ApplicationContext/BeanFactory
  - RestTemplate
  - ViewResolver만 단독으로 사용

**정답**: ApplicationContext/BeanFactory

**해설**: 스프링 컨테이너는 설정과 조건(프로필, @Conditional 등)에 따라 구현체를 선택해 빈을 생성·주입한다. 이는 추상 팩토리처럼 “구체 타입 선택과 생성”을 캡슐화하는 동작과 동일한 핵심을 가진다. Interceptor/RestTemplate/ViewResolver는 각각 특정 관심사의 컴포넌트일 뿐, 제품군 생성 추상화와는 직접적이지 않다.

#### 문제 3 (복수 응답)
**문제**: 다음 중 추상 팩토리 패턴을 적용하기 좋은 경우를 모두 고르시오.

- 보기
  - 플랫폼(웹/모바일)에 따라 UI 컴포넌트 세트가 달라지는 경우
  - 데이터 접근 기술(JPA/JDBC)에 따라 리포지토리 구현군이 달라지는 경우
  - 단일 클래스 인스턴스 하나만 필요하고 변형이 없는 경우
  - 멀티 테넌트 환경에서 테넌트별 브랜드/테마 컴포넌트 세트가 다른 경우
  - 동일한 구현체를 영구적으로 고정해야 하는 경우

**정답**: 플랫폼(웹/모바일), 데이터 접근 기술(JPA/JDBC), 멀티 테넌트별 테마 구성

**해설**:
- 플랫폼별 UI는 버튼/체크박스/아이콘 등 호환되는 컴포넌트 “제품군”을 일관되게 교체해야 하므로 적합하다.
- 데이터 접근 기술별로 JPA/Mongo/JDBC 리포지토리 구현군이 달라지는 경우, 동일한 리포지토리 인터페이스를 유지하면서 팩토리로 제품군을 선택할 수 있다.
- 멀티 테넌트 환경에서 테넌트별 테마/브랜딩 컴포넌트 세트를 교체해야 하므로 추상 팩토리로 일관된 교체가 가능하다.
- 단일 클래스만 필요하거나 구현체를 고정해야 하는 경우는 추상 팩토리의 장점(교체/일관된 세트 생성)을 활용하지 못하므로 부적절하다.

# 정답 및 해설

이 문서는 각 장의 확인 문제에 대한 정답과 해설을 제공합니다.

## 목차

### 01. 생성 패턴 (Creational Patterns)
- 01-1. [추상 팩토리 (Abstract Factory)](#01-1-추상-팩토리-abstract-factory)
- 01-2. [빌더 (Builder)](#01-2-빌더-builder)
- 01-3. 팩토리 메서드 (Factory Method)
- 01-4. 프로토타입 (Prototype)
- 01-5. 싱글톤 (Singleton)

### 02. 구조 패턴 (Structural Patterns)
- 02-1. 어댑터 (Adapter)
- 02-2. 브리지 (Bridge)
- 02-3. 컴포지트 (Composite)
- 02-4. 데코레이터 (Decorator)
- 02-5. 퍼사드 (Facade)
- 02-6. 플라이웨이트 (Flyweight)
- 02-7. 프록시 (Proxy)

### 03. 행위 패턴 (Behavioral Patterns)
- 03-1. 책임 연쇄 (Chain of Responsibility)
- 03-2. 커맨드 (Command)
- 03-3. 인터프리터 (Interpreter)
- 03-4. 반복자 (Iterator)
- 03-5. 중재자 (Mediator)
- 03-6. 메멘토 (Memento)
- 03-7. 옵저버 (Observer)
- 03-8. 상태 (State)
- 03-9. 전략 (Strategy)
- 03-10. 템플릿 메서드 (Template Method)
- 03-11. 방문자 (Visitor)




---

<a id="01-1-추상-팩토리-abstract-factory"></a>

### 01-1. 추상 팩토리 (Abstract Factory)

#### 문제 1
**문제**: 추상 팩토리 패턴의 주된 목적은 무엇인가?

- 보기
  - 객체 생명주기 전체(생성-사용-소멸)를 강제한다.
  - 관련 객체들의 일관된 세트를 생성하되, 구체 클래스를 감춘다.
  - 객체의 내부 상태를 캡슐화하고 복구한다.
  - 요청을 캡슐화하여 서로 다른 큐에 전달한다.

**정답**: 관련 객체들의 일관된 세트를 생성하되, 구체 클래스를 감춘다.

**해설**: 추상 팩토리는 서로 호환되는 제품군(예: 버튼·체크박스)을 한 번에 생성하게 해 일관성을 보장하고, 클라이언트가 구체 클래스를 알 필요 없이 인터페이스에만 의존하도록 만든다. 생명주기 관리나 상태 복구, 요청 캡슐화는 각각 다른 패턴(예: 템플릿 메서드/메멘토/커맨드)에 해당한다.

#### 문제 2
**문제**: 다음 중 스프링에서 추상 팩토리와 가장 밀접한 구성요소는 무엇인가?

- 보기
  - HandlerInterceptor
  - ApplicationContext/BeanFactory
  - RestTemplate
  - ViewResolver만 단독으로 사용

**정답**: ApplicationContext/BeanFactory

**해설**: 스프링 컨테이너는 설정과 조건(프로필, @Conditional 등)에 따라 구현체를 선택해 빈을 생성·주입한다. 이는 추상 팩토리처럼 “구체 타입 선택과 생성”을 캡슐화하는 동작과 동일한 핵심을 가진다. Interceptor/RestTemplate/ViewResolver는 각각 특정 관심사의 컴포넌트일 뿐, 제품군 생성 추상화와는 직접적이지 않다.

#### 문제 3 (복수 응답)
**문제**: 다음 중 추상 팩토리 패턴을 적용하기 좋은 경우를 모두 고르시오.

- 보기
  - 플랫폼(웹/모바일)에 따라 UI 컴포넌트 세트가 달라지는 경우
  - 데이터 접근 기술(JPA/JDBC)에 따라 리포지토리 구현군이 달라지는 경우
  - 단일 클래스 인스턴스 하나만 필요하고 변형이 없는 경우
  - 멀티 테넌트 환경에서 테넌트별 브랜드/테마 컴포넌트 세트가 다른 경우
  - 동일한 구현체를 영구적으로 고정해야 하는 경우

**정답**: 플랫폼(웹/모바일), 데이터 접근 기술(JPA/JDBC), 멀티 테넌트별 테마 구성

**해설**:
- 플랫폼별 UI는 버튼/체크박스/아이콘 등 호환되는 컴포넌트 “제품군”을 일관되게 교체해야 하므로 적합하다.
- 데이터 접근 기술별로 JPA/Mongo/JDBC 리포지토리 구현군이 달라지는 경우, 동일한 리포지토리 인터페이스를 유지하면서 팩토리로 제품군을 선택할 수 있다.
- 멀티 테넌트 환경에서 테넌트별 테마/브랜딩 컴포넌트 세트를 교체해야 하므로 추상 팩토리로 일관된 교체가 가능하다.
- 단일 클래스만 필요하거나 구현체를 고정해야 하는 경우는 추상 팩토리의 장점(교체/일관된 세트 생성)을 활용하지 못하므로 부적절하다.


---

<a id="01-2-빌더-builder"></a>

### 01-2. 빌더 (Builder)

#### 문제 1
**문제**: 빌더 패턴의 핵심 아이디어로 가장 적절한 것은?

- 보기
  - 구체 팩토리별로 일관된 제품군을 생성한다.
  - 객체의 내부 상태를 스냅샷으로 저장하고 복구한다.
  - 복잡한 객체 생성을 단계별로 분리하고 최종 단계에서 완성한다.
  - 알고리즘의 골격을 정의하고 하위 클래스가 일부 단계를 재정의한다.

**정답**: 복잡한 객체 생성을 단계별로 분리하고 최종 단계에서 완성한다.

**해설**: 빌더는 많은 선택적 인자나 조건부 조립이 필요한 경우에 적합하며, 생성 과정을 단계별로 나누어 가독성과 안전성을 높인다. 템플릿 메서드/메멘토/추상 팩토리 등의 의도와는 다르다.

#### 문제 2
**문제**: 다음 중 스프링에서 "빌더" 스타일 API로 분류되기 어려운 것은?

- 보기
  - RestTemplateBuilder
  - WebClient.Builder
  - UriComponentsBuilder
  - JdbcTemplate 자체(쿼리 실행 도우미)

**정답**: JdbcTemplate 자체(쿼리 실행 도우미)

**해설**: JdbcTemplate은 쿼리 실행을 돕는 템플릿 유틸리티로, 최종 객체를 단계적으로 구성해 build()로 완성하는 전형적 빌더와는 성격이 다르다. 나머지는 모두 객체를 체이닝 설정 후 build() 혹은 toUri 등으로 생성한다.

#### 문제 3 (복수 응답)
**문제**: 빌더 패턴을 적용하기 좋은 경우를 모두 고르시오.

- 보기
  - 선택적 인자가 많은 불변 설정 객체를 만들 때
  - HTTP 클라이언트 구성 옵션(타임아웃/헤더/리트라이 등)을 단계적으로 설정할 때
  - 단일 생성자에 인자가 1~2개뿐인 단순 값 객체를 만들 때
  - 동일 절차로 프로파일별 다른 프리셋을 손쉽게 만들고 싶을 때
  - 런타임에 객체 제품군의 일관성을 강제하고 싶을 때

**정답**: 선택적 인자가 많은 불변 설정 객체, HTTP 클라이언트 구성, 프로파일별 프리셋 구성

**해설**:
- 불변 설정 객체에 선택적 속성이 많으면 빌더로 누락/순서 오류를 줄일 수 있다.
- HTTP 클라이언트는 옵션이 다양해 단계적 설정과 최종 build가 적합하다.
- 프로파일별 프리셋은 동일 절차로 다른 결과를 생성하므로 빌더의 장점이 크다.
- 인자가 매우 적은 단순 객체, 혹은 제품군 일관성 강제(이는 추상 팩토리의 관심사)는 빌더와 맞지 않는다.


---

<a id="01-3-팩토리-메서드-factory-method"></a>

### 01-3. 팩토리 메서드 (Factory Method)

#### 문제 1
**문제**: 팩토리 메서드 패턴의 핵심 아이디어로 가장 적절한 것은?

- 보기
  - 관련 객체들의 일관된 세트를 한 번에 생성한다.
  - 상위 알고리즘 속 생성 훅(factoryMethod)을 두고, 구체 생성은 하위 클래스에서 결정한다.
  - 복잡한 객체 생성을 단계별로 분해하여 최종 build()에서 완성한다.
  - 객체의 내부 상태를 스냅샷으로 저장하고 복구한다.

**정답**: 상위 알고리즘 속 생성 훅(factoryMethod)을 두고, 구체 생성은 하위 클래스에서 결정한다.

**해설**: 팩토리 메서드는 Creator의 알고리즘 흐름 안에 생성 훅(factoryMethod)을 두고, 어떤 Product를 만들지는 하위 클래스가 오버라이드해 결정합니다. 제품군 일관 생성은 추상 팩토리, 단계적 조립은 빌더, 상태 스냅샷은 메멘토의 의도입니다.

#### 문제 2
**문제**: 다음 중 스프링에서 ‘팩토리 메서드’로 보기 어려운 것은?

- 보기
  - @Configuration 클래스의 @Bean 메서드
  - RepositoryFactorySupport가 하위 클래스에 위임하는 생성 훅
  - AbstractViewResolver 계층의 View 생성 보호 메서드
  - RestTemplateBuilder.build()의 빌더 완성 메서드

**정답**: RestTemplateBuilder.build()의 빌더 완성 메서드

**해설**: build()는 빌더 패턴의 최종 생성 단계입니다. @Bean 메서드는 컨테이너가 호출하는 명시적 팩토리 메서드로 볼 수 있고, RepositoryFactorySupport/AbstractViewResolver 계층의 보호 메서드는 하위 클래스가 구체 생성을 결정하는 전형적 팩토리 메서드 훅입니다.

#### 문제 3 (복수 응답)
**문제**: 팩토리 메서드 패턴을 적용하기 좋은 경우를 모두 고르시오.

- 보기
  - 상위 흐름은 고정이나, 생성되는 타입만 바뀌는 확장 요구가 많을 때
  - 표현(HTML/JSON/CSV 등)별로 다른 View를 같은 흐름에서 선택해야 할 때
  - 선택적 속성이 많은 불변 설정 객체를 단계적으로 조립할 때
  - 프레임워크가 생성 시점을 제어하고 사용자는 확장 포인트에서 구체 생성을 결정할 때
  - 단일 구현만 영구적으로 고정해야 하는 경우

**정답**: 상위 흐름 고정·타입만 변경, 표현별 View 선택, 프레임워크 제어·사용자 확장 포인트

**해설**:
- 상위 흐름 고정 + 타입만 변경: Creator 템플릿을 유지하면서 하위 클래스 교체로 확장하기 좋습니다.
- 표현별 View 선택: 같은 컨트롤 흐름에서 다른 View(Product)를 선택·생성하기 적합합니다.
- 프레임워크 제어/사용자 확장: 생성 시점은 프레임워크가, 구체 생성은 확장 포인트에서 결정하는 구조는 전형적인 팩토리 메서드입니다.
- 불변 설정의 단계적 조립은 빌더의 관심사이며, 단일 구현을 영구 고정하는 경우는 팩토리 메서드의 장점이 약합니다.


---

<a id="01-4-프로토타입-prototype"></a>

### 01-4. 프로토타입 (Prototype)

#### 문제 1
**문제**: 프로토타입 패턴의 핵심 아이디어로 가장 적절한 것은?

- 보기
  - 상위 알고리즘 속 생성 훅을 두고 하위 클래스에서 구체 생성을 결정한다.
  - 복잡한 객체 생성을 단계별로 분리하여 최종 단계에서 완성한다.
  - 원형 인스턴스를 복제하여 새 객체를 만든다.
  - 관련 객체들의 일관된 세트를 한 번에 생성한다.

**정답**: 원형 인스턴스를 복제하여 새 객체를 만든다.

**해설**: 프로토타입의 본질은 “복제 기반 생성”입니다. new로 초기화 로직을 반복하는 대신, 이미 준비된 원형을 복사해 빠르게 인스턴스를 만듭니다. 생성 훅/단계별 조립/제품군 생성은 각각 팩토리 메서드/빌더/추상 팩토리의 의도입니다.

#### 문제 2
**문제**: 스프링의 prototype 스코프에 대한 설명으로 가장 올바른 것은?

- 보기
  - GoF Prototype처럼 원형 객체의 clone을 호출한다.
  - getBean 호출마다 컨테이너가 새 인스턴스를 만들어 준다.
  - 싱글톤 빈과 동일하게 1개 인스턴스만 유지한다.
  - 동일 빈 이름에 대해 항상 깊은 복사를 보장한다.

**정답**: getBean 호출마다 컨테이너가 새 인스턴스를 만들어 준다.

**해설**: 스프링의 prototype 스코프는 ‘매 요청 시 신규 생성’을 의미합니다. 내부적으로 clone을 강제하지 않으며, 깊은 복사를 보장하지도 않습니다. GoF Prototype은 원형 객체가 복제 규칙을 캡슐화하는 패턴으로 개념이 다릅니다.

#### 문제 3 (복수 응답)
**문제**: 다음 중 “깊은 복사”가 필요한 상황을 모두 고르시오.

- 보기
  - 원형과 복제본이 동일한 컬렉션 인스턴스를 공유하면 안 될 때
  - 불변 값 객체만으로 구성되어 공유 안전할 때
  - JPA 엔티티를 복제하며 연관 컬렉션을 독립적으로 편집해야 할 때
  - 식별자/감사 필드를 그대로 유지해야 할 때
  - 템플릿 DTO를 복제하되 내부 리스트를 새로 만들어야 할 때

**정답**: 원형과 복제본이 동일한 컬렉션 인스턴스를 공유하면 안 될 때, JPA 엔티티를 복제하며 연관 컬렉션을 독립적으로 편집해야 할 때, 템플릿 DTO를 복제하되 내부 리스트를 새로 만들어야 할 때

**해설**:
- 컬렉션/가변 참조 공유 금지: 원형과 복제본이 같은 리스트/맵을 공유하면 부작용이 발생합니다. 깊은 복사로 분리해야 합니다.
- JPA 연관 컬렉션: 독립 편집이 필요하면 컬렉션 요소 및 참조를 새로 만들어야 합니다(식별자 재설정 포함).
- 템플릿 DTO: 내부 리스트를 새로 만들어 원형과 복제본 간 상태 공유를 차단합니다.
- 불변 값 객체만으로 구성된 경우엔 얕은 복사도 안전합니다.
- 식별자/감사 필드는 보통 새로 생성/초기화해야 하며, ‘그대로 유지’는 도메인 규칙 위반 가능성이 큽니다.


---

<a id="01-5-싱글톤-singleton"></a>

### 01-5. 싱글톤 (Singleton)

#### 문제 1
**문제**: 싱글톤 패턴의 핵심 의도로 가장 적절한 것은?

- 보기
  - 복잡한 객체 생성을 단계별로 분리한다.
  - 애플리케이션 전역에서 단 하나의 인스턴스만 존재하도록 보장한다.
  - 관련 객체들의 일관된 세트를 한 번에 생성한다.
  - 상위 알고리즘의 생성 훅을 하위 클래스가 결정한다.

**정답**: 애플리케이션 전역에서 단 하나의 인스턴스만 존재하도록 보장한다.

**해설**: 싱글톤의 핵심은 유일성과 전역 접근입니다. 단계적 생성은 빌더, 제품군 생성은 추상 팩토리, 생성 훅은 팩토리 메서드의 의도입니다.

#### 문제 2
**문제**: 다음 중 "스프링의 싱글톤 스코프"에 대한 설명으로 가장 올바른 것은?

- 보기
  - getBean 호출마다 새 인스턴스를 만든다.
  - 같은 컨테이너 내에서 동일 빈은 하나의 인스턴스로 관리된다.
  - 전역 정적 getInstance로만 접근해야 한다.
  - 항상 상태를 보관해도 안전하다.

**정답**: 같은 컨테이너 내에서 동일 빈은 하나의 인스턴스로 관리된다.

**해설**: 스프링의 기본 스코프는 싱글톤으로, 컨테이너가 하나의 인스턴스를 생성/공유합니다. 매 호출 신규 생성은 prototype 스코프이며, 정적 전역 접근은 스프링에서 권장되지 않습니다. 싱글톤은 공유되므로 내부 상태 보관은 동시성 문제를 유발할 수 있습니다.

#### 문제 3 (복수 응답)
**문제**: 싱글톤을 적용하거나 설계할 때의 올바른 접근을 모두 고르시오.

- 보기
  - 빈은 가능하면 무상태로 유지하고, 요청별 데이터는 지역 변수로 처리한다.
  - 전역 정적 접근을 선호하고 DI는 피한다.
  - 비용이 큰 리소스(ObjectMapper, 커넥션 풀 등)는 싱글톤 빈으로 공유한다.
  - 상태 공유가 필요하면 ThreadLocal을 무조건 사용한다.
  - 환경/프로필별로 다른 구현을 인터페이스 뒤에서 교체할 수 있게 설계한다.

**정답**: 빈은 가능하면 무상태로 유지, 비용이 큰 리소스 공유, 환경/프로필별 교체 가능 설계

**해설**:
- 무상태 설계는 공유 가변 상태로 인한 경쟁 조건을 줄입니다.
- ObjectMapper/커넥션 풀 등은 생성 비용이 크고 재사용성이 높아 싱글톤 공유가 적합합니다.
- 인터페이스 뒤에서 구현 교체(@Profile/@Conditional)는 전역 정적 접근보다 테스트/유연성 측면에서 우수합니다.
- 전역 정적 접근 선호는 테스트/치환을 어렵게 합니다.
- ThreadLocal은 누수/컨텍스트 전파 이슈가 있어 신중히, 한정된 상황에서만 사용해야 합니다.


---

<a id="02-1-어댑터-adapter"></a>

### 02-1. 어댑터 (Adapter)

#### 문제 1
**문제**: 어댑터 패턴의 핵심 의도로 가장 적절한 것은?

- 보기
  - 객체 생성 과정을 단계적으로 분리한다.
  - 서브클래싱으로 생성을 지연시킨다.
  - 호환되지 않는 인터페이스를 변환하여 재사용 가능하게 한다.
  - 동일한 제품군을 일관되게 생성한다.

**정답**: 호환되지 않는 인터페이스를 변환하여 재사용 가능하게 한다.

**해설**: 어댑터의 의도는 인터페이스 불일치를 해결해 기존 객체를 변경 없이 새 계약(Target)에 맞추는 것입니다. 단계적 생성/지연 생성/제품군 생성은 각각 빌더/팩토리 메서드/추상 팩토리의 관심사입니다.

#### 문제 2
**문제**: 다음 중 스프링에서 어댑터 패턴의 대표적 적용으로 가장 올바른 것은?

- 보기
  - BeanPostProcessor가 빈 초기화를 최적화한다.
  - HandlerAdapter가 다양한 컨트롤러를 DispatcherServlet 계약에 맞춘다.
  - @Transactional이 트랜잭션 경계를 관리한다.
  - ApplicationEventPublisher가 이벤트를 발행한다.

**정답**: HandlerAdapter가 다양한 컨트롤러를 DispatcherServlet 계약에 맞춘다.

**해설**: DispatcherServlet은 직접 컨트롤러 종류를 알지 않고, 여러 HandlerAdapter가 각기 다른 컨트롤러 스타일을 공통 계약으로 맞춰 실행합니다. 이는 전형적인 어댑터 구조입니다.

#### 문제 3 (복수 응답)
**문제**: 어댑터를 적용하기 좋은 상황을 모두 고르시오.

- 보기
  - 외부 결제/메일 SDK를 우리 도메인 계약에 맞춰야 할 때
  - 동일 도메인의 하위 타입을 상위 타입으로 업캐스팅할 때
  - 프레임워크가 요구하는 콜백 인터페이스에 레거시 객체를 연결해야 할 때
  - 외부 라이브러리 교체 가능성을 높이고 테스트 대체를 쉽게 하고 싶을 때
  - 단일 구현만 고정하여 영구적으로 변경하지 않으려 할 때

**정답**: 외부 SDK를 우리 계약에 맞춤, 프레임워크 콜백에 레거시 연결, 교체 가능성과 테스트 용이성 확보

**해설**:
- 외부 SDK/레거시를 표준 계약(Target)으로 감싸면 결합을 낮추고 도메인 모델을 보호할 수 있습니다.
- 프레임워크가 요구하는 콜백(예: DispatcherServlet-HandlerAdapter)에 기존 객체를 연결하는 것이 어댑터의 전형적 쓰임입니다.
- Target 뒤에서 여러 어댑터를 교체할 수 있어 벤더 교체/테스트 대체(목/스텁)가 쉬워집니다.
- 업캐스팅은 언어 기능으로 해결되므로 어댑터의 문제 영역이 아닙니다.
- 단일 구현을 고정하려는 목적은 어댑터의 장점을 활용하지 못합니다.


---

<a id="02-2-브리지-bridge"></a>

### 02-2. 브리지 (Bridge)

#### 문제 1
**문제**: 브리지 패턴의 핵심 의도로 가장 적절한 것은?

- 보기
  - 호환되지 않는 인터페이스를 변환해 재사용 가능하게 한다.
  - 추상과 구현을 분리해 각자 독립적으로 확장 가능하게 한다.
  - 동일 제품군 객체를 일관되게 생성한다.
  - 객체 생성을 단계적으로 분리하여 완성한다.

**정답**: 추상과 구현을 분리해 각자 독립적으로 확장 가능하게 한다.

**해설**: 브리지는 상속 대신 합성으로 추상(Abstraction)과 구현(Implementor)을 느슨하게 결합합니다. 두 축을 독립 확장할 수 있어 클래스 폭증을 방지합니다. 인터페이스 변환은 어댑터, 제품군 생성은 추상 팩토리, 단계적 생성은 빌더의 관심사입니다.

#### 문제 2
**문제**: 다음 중 스프링에서 브리지의 의도와 가장 잘 맞는 사례는?

- 보기
  - HandlerAdapter로 컨트롤러 호출 계약을 맞춘다.
  - Cache/CacheManager 추상 뒤에서 Caffeine/Redis 구현을 교체한다.
  - 프록시로 지연 로딩을 구현한다.
  - 템플릿 메서드로 하위 클래스에서 생성 훅을 결정한다.

**정답**: Cache/CacheManager 추상 뒤에서 Caffeine/Redis 구현을 교체한다.

**해설**: 스프링 캐시 추상화는 상위 계약(Cache/CacheManager)과 하위 구현(Caffeine/Redis 등)을 분리해 교체 가능성을 제공합니다. HandlerAdapter는 어댑터, 프록시는 지연/접근 제어, 템플릿 메서드는 생성 훅 결정과 관련이 깊습니다.

#### 문제 3 (복수 응답)
**문제**: 브리지를 적용하기 좋은 상황을 모두 고르시오.

- 보기
  - 상위 정책과 하위 기술을 각자 바꿔가며 조합해야 할 때
  - 구현 교체 가능성이 낮고 단일 상속만으로 충분할 때
  - 운영/테스트 환경에 따라 하위 리소스 접근 방식을 바꿔야 할 때
  - 상속 조합으로 클래스 수가 폭증할 것이 예상될 때
  - 동일 도메인 하위 타입을 상위 타입으로 업캐스팅할 때

**정답**: 상위 정책과 하위 기술을 각자 바꿔가며 조합, 운영/테스트별 하위 리소스 교체, 상속 조합 폭증 예상 시

**해설**:
- 추상/구현 2축을 독립적으로 바꿔가며 조합해야 할 때 브리지가 적합합니다.
- 환경에 따라 하위 구현(파일/클라우드 저장소, HTTP 클라이언트 등)을 교체하기 쉬워집니다.
- 상속만으로 조합을 표현하면 클래스가 폭증하므로, 합성 기반 브리지가 더 유지보수에 유리합니다.
- 업캐스팅은 언어 기능으로 해결되며 브리지의 문제 영역이 아닙니다.


---

<a id="02-3-컴포지트-composite"></a>

### 02-3. 컴포지트 (Composite)

#### 문제 1
**문제**: 컴포지트 패턴의 핵심 의도로 가장 적절한 것은?

- 보기
  - 호환되지 않는 인터페이스를 변환해 재사용 가능하게 한다.
  - 부분-전체 계층을 동일한 인터페이스로 다루게 한다.
  - 추상과 구현을 분리해 독립 확장을 가능하게 한다.
  - 객체 생성 과정을 단계적으로 분리한다.

**정답**: 부분-전체 계층을 동일한 인터페이스로 다루게 한다.

**해설**: 컴포지트는 Leaf와 Composite를 같은 상위 타입(Component)으로 다루어 트리 구조를 투명하게 사용하게 합니다. 인터페이스 변환은 어댑터, 추상/구현 분리는 브리지, 단계적 생성은 빌더에 해당합니다.

#### 문제 2
**문제**: 다음 중 스프링에서 컴포지트의 전형적 사례로 가장 적절한 것은?

- 보기
  - HandlerInterceptor 체인으로 요청을 전처리한다.
  - CompositePropertySource로 여러 PropertySource를 하나처럼 조회한다.
  - HandlerAdapter로 다양한 컨트롤러를 호출 계약에 맞춘다.
  - Proxy를 이용해 지연 로딩을 구현한다.

**정답**: CompositePropertySource로 여러 PropertySource를 하나처럼 조회한다.

**해설**: 여러 PropertySource를 내부에 보유하고 상위 타입처럼 동작하는 CompositePropertySource는 전형적인 컴포지트입니다. Interceptor 체인은 책임 연쇄, HandlerAdapter는 어댑터, Proxy는 접근 제어/지연과 관련이 큽니다.

#### 문제 3 (복수 응답)
**문제**: 컴포지트를 적용하기 좋은 상황을 모두 고르시오.

- 보기
  - 메뉴/카테고리와 같은 트리를 동일한 API로 렌더링해야 할 때
  - 단일 구현만 있고 트리 구조가 전혀 없을 때
  - 여러 상태 점검 컴포넌트를 하나의 상위 헬스로 묶어 노출해야 할 때
  - 하위 기술을 상위 정책과 독립적으로 교체해야 할 때
  - 여러 프로세서를 연결해 하나의 프로세서처럼 동작시키고 싶을 때

**정답**: 메뉴/카테고리 트리 렌더링, 여러 상태 점검을 상위 헬스로 묶기, 여러 프로세서를 연결해 하나처럼 동작

**해설**:
- UI/도메인 트리(메뉴/카테고리)를 동일한 인터페이스로 다루면 렌더/검증을 단순화할 수 있습니다.
- Actuator의 CompositeHealthContributor처럼 여러 헬스 컴포넌트를 상위로 묶어 노출하는 구조가 적합합니다.
- Spring Batch의 CompositeItemProcessor/Writer처럼 구성요소를 묶어 하나의 상위 타입으로 동작시키는 경우도 전형적입니다.
- 하위 기술을 상위 정책과 독립 교체는 브리지에 가깝고, 트리 구조가 전혀 없는 경우는 컴포지트의 이점을 활용하기 어렵습니다.


---

<a id="02-4-데코레이터-decorator"></a>

### 02-4. 데코레이터 (Decorator)

#### 문제 1
**문제**: 데코레이터 패턴의 핵심 의도로 가장 적절한 것은?

- 보기
  - 호환되지 않는 인터페이스를 변환해 재사용 가능하게 한다.
  - 객체에 새로운 책임을 동적으로 추가하되 동일한 인터페이스를 유지한다.
  - 추상과 구현을 분리해 독립적으로 확장한다.
  - 동일 제품군 객체를 일관되게 생성한다.

**정답**: 객체에 새로운 책임을 동적으로 추가하되 동일한 인터페이스를 유지한다.

**해설**: 데코레이터는 동일한 Component 계약을 구현하는 래퍼로 기존 객체를 감싼 뒤, 호출의 전후로 기능을 덧붙입니다. 인터페이스 변환은 어댑터, 추상/구현 분리는 브리지, 제품군 생성은 추상 팩토리의 관심사입니다.

#### 문제 2
**문제**: 다음 중 스프링에서 데코레이터의 대표적 적용으로 가장 올바른 것은?

- 보기
  - HandlerAdapter로 다양한 컨트롤러를 호출한다.
  - ContentCachingRequestWrapper로 HttpServletRequest를 감싸 바디 재사용을 가능하게 한다.
  - @Transactional로 트랜잭션 경계를 관리한다.
  - RestTemplate의 HttpMessageConverter를 통해 JSON을 변환한다.

**정답**: ContentCachingRequestWrapper로 HttpServletRequest를 감싸 바디 재사용을 가능하게 한다.

**해설**: ContentCachingRequestWrapper는 HttpServletRequest와 동일한 계약을 구현하며 내부 위임으로 원래 요청을 감싼 뒤, 바디 캐시 기능을 덧붙이는 전형적 데코레이터입니다. HandlerAdapter는 어댑터, @Transactional은 트랜잭션 관리, HttpMessageConverter는 인터페이스 변환(어댑터 성격)에 가깝습니다.

#### 문제 3 (복수 응답)
**문제**: 데코레이터를 적용하기 좋은 상황을 모두 고르시오.

- 보기
  - 기존 계약은 유지하면서 로깅/캐싱/검증 같은 부가 기능을 추가해야 할 때
  - 새로운 메서드를 추가해 인터페이스 자체를 바꿔야 할 때
  - 상속으로 조합이 폭증할 것이 예상될 때
  - 런타임 조건에 따라 기능을 켜고 끄며 조합해야 할 때
  - 타입 변환으로 호환되지 않는 인터페이스를 맞춰야 할 때

**정답**: 기존 계약 유지 + 부가 기능 추가, 상속 조합 폭증 예상 시, 런타임 조건에 따른 기능 조합

**해설**:
- 동일 인터페이스를 유지한 채 부가 기능(로깅, 캐싱, 검증, 메트릭 등)을 투명하게 추가하는 데 적합합니다.
- 상속으로 다양한 조합을 만들려면 클래스가 폭증하므로, 합성 기반의 데코레이터가 유리합니다.
- 실행 환경/설정에 따라 데코레이터를 켜고 끄면 유연한 구성이 가능합니다.
- 인터페이스 자체를 바꾸는 경우는 데코레이터보다 어댑터/인터페이스 리디자인이 필요합니다.
- 인터페이스 불일치 해결은 어댑터의 문제 영역입니다.
